%!TEX ROOT=../diploma-thesis.tex

\chapter{Rešerše}\label{ch:reserse}

% TODO: úvod

\section{Modelem ř\'{\i}zená architektura}

Modelem řízená architektura (\gls{MDA}) se zaměřuje na využití
modelovacích nástrojů a jejich následnou transformaci do
spustitelného kódu pomocí generativních nástrojů~\cite{soley2000model}.
Za specifikací \gls{MDA} stojí konsorcium Object Modeling Group (\gls{OMG}),
která se zaměřuje na standardizaci modelovacích standardů pro software
a stojí za modelovacím jazykem \gls{UML}, který je de facto globálním standardem
pro vizualizaci statických i dynamických aspektů softwarových systémů.

\gls{MDA} využívá Platform Independent Model (\gls{PIM}),
který popisuje systém pomocí platformově nezávislého \gls{DSL},
typicky pomocí \gls{UML}. Ten je následně převeden do
Platform Specific Model (\gls{PSM}), tedy modelu využívajícího
specifických aspektů platformy, pro kterou má být systém postaven.
Tím může být obecný programovací jazyk či jiné \gls{DSL}.

Hlavní výhodou \gls{MDA} je vysoká úroveň abstrakce a z toho vyplívající
deduplikace kódu. Pokud je byznysové pravidlo zachyceno v nejvyšší
úrovni modelu, může pak snadno být distribuováno do systému na všechna
místa, kde má být aplikováno. Další výhodou je usnadnění tvorby a zvýšení
kvality kódu díky jeho automatickému generování.

Hlavní nevýhodou \gls{MDA}, která zabraňuje jejímu využití
pro náš účel, je jednosměrný proces, kterým je kód z modelu
generován. Pokud dojde ke změně požadavků, je potřeba přegenerovat
celou aplikaci od \gls{PIM} až k finálnímu kódu. Kód, který bylo
nutno doplnit ručně, může snadno zastarat a je potřeba ho manuálně
projít a opravit. Změna byznysových pravidel v našem případě by
navíc při využití \gls{MDA} vyžadovala znovu-nasazení celého
systému, což je v přímém rozporu s požadavkem na možnost dynamicky
upravovat či přidávat byznysová pravidla za běhu systému.

Další nevýhodou tohoto přístupu je jeho závislost na \gls{OOP},
které samotné není schopné se efektivně vypořádat s průřezovými
problémy~\cite{cemus2014aspect}, jak si popíšeme v sekci~\ref{sec:aop}.
Ačkoliv je \gls{MDA} známá již od roku 2000, generativní nástroje pro
její podporu jsou stále nevyspělé a pro některé platformy úplně chybí.

\section{Síťové architektury}

Jak jsme již naznačili v sekci~\ref{sec:soa}, architektura orientovaná na služby staví
na počítačových síťích, díky kterým spolu mohou jednotlivé služby efektivně komunikovat.
Proto je vhodné provést rešerši základních síťových architektur,
abychom mohli co nejlépe navrhnout framework pro centrální správu
a automatickou distribuci byznysových pravidel.

\subsection{Architektura klient-server}\label{sec:client-server}

Model klient-server popisuje vztah mezi komponentami systému, klienty a serverem.
Klient zašle požadavek serveru a ten mu vrátí odpověď~\cite{berson1992client}.
Tento model může být použit obecně i v rámci jednoho počítače,
nejčastěji je však využíván v síťové komunikaci mezi více počítači.
V tomto případě klient sestaví síťové spojení k serveru a po získání odpovědi
od serveru spojení zase uzavře. Schéma komunikace je znázorněno
na obrázku ~\ref{fig:client-server}.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.6\linewidth]{figures/client-server.pdf}
    \caption{Architektura klient-server}
    \label{fig:client-server}
\end{figure}

Tato architektura je jednou ze základních stavebních kamenů
internetových protokolů. Je využívána zejména protokolem
\gls{TCP}~\cite{postel1981transmission}, který je využíván ke
komunikaci v síti Internet. Jako příklad si můžeme představit
prohlížení internetových stránek. Uživatel zadá \gls{URL} adresu
stránky, kterou chce navštívit, a internetový prohlížeč, potažmo uživatelův osobní počítač,
v roli klienta odešle požadavek na server nacházející se na dané adrese.
Server požadavek přijme, zpracuje, a odešle odpověď obsahující
tělo webové stránky. Klient stránku přijme a zobrazí pro koncového
uživatele.

Tento přístup má několik zásadních výhod, díky kterým se stal
široce využívaným. Díky svojí velmi obecné myšlence je nezávislý
na jakékoliv platformě a jako klient i server mohou sloužit
jak vysoce výkonné počítače, tak i osobní počítače nebo chytré telefony,
z nichž každý může využívat odlišné operační systémy –
stačí aby klient i server uměl komunikovat stejným protokolem.
Zároveň tato architektura přesouvá byznysovou logiku a
ukládání dat na server a díky tomu umožňuje
snadnější kontrolu nad systémem a jeho centrální administraci. S tím
je spojena i snažší škálovatelnost systému. V neposlední řadě
přináší model klient-server díky centralizaci i lepší zabezpečení,
kdy server může jasně definovat a vynucovat přístupová pravidla.

Hlavní nevýhodu této architektury je vytvoření jednoho centrálního bodu,
jehož výpadek ochromí funkci celého systému (v angličtině
\textit{single point of failure}). Tímto bodem je server.
Pokud na serveru nastane chyba či výpadek, žádný z klientů není schopen využívat
jeho služeb.

Pro sdílení byznysových pravidel se tato architektura jeví
jako vhodná. Klient, který potřebuje byznysové pravidlo ke
svému běhu, by zažádal server o dané pravidlo a poté by
se postaral o jeho spuštění. Tím by bylo dosaženo automatické
distribuce a integrace byznysových pravidel. Vzhledem k tomu,
že server je v této architetkuře centrální autorita, usnadnila
by se tak centrální správa byznysových pravidel.

\subsection{Architektura Peer-to-peer}\label{sec:p2p}

Opakem modelu klient-server je síťová architektura zvaná \textit{Peer-to-peer (\gls{P2P})}.
Jednotlivé počítače v síti spolu komunikují přímo, bez centrální autority.
Všechny počítače v síti jsou si vzájemně rovnocenné.~\cite{fox2001peer}
Na obrázku~\ref{fig:peer-to-peer} je architektura znázorněna.
Hlavním cílem \gls{P2P} sítí je distribuce dat nebo výpočetních operací.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.4\linewidth]{figures/peer-to-peer.pdf}
    \caption{Architektura peer-to-peer}
    \label{fig:peer-to-peer}
\end{figure}

Jednotliví klienti mezi sebou zpravidla vytvářejí virtuální síť, tzv. \textit{overlay},
která je postavená nad fyzickou sítí, přes kterou jsou reálně zasílány zprávy.
Typicky je tato virtuální síť podmnožinou fyzické sítě. Výhodou tohoto přístupu je,
že klienti jsou abstrahováni od fyzického uspořádání počítačů a mohou spolu komunikovat napřímo,
i když mezi nimi mohou fyzicky být v síti zapojeny jiné počítače.

Nespornou výhodou architektury \gls{P2P} je, že s rostoucím počtem klientů roste i
kapacita a výkon sítě, narozdíl od modelu klient-server, kdy se klienti musí dělit o výkon serveru.
Navíc v takové síti neexistuje \textit{single point of failure} a tak se zvyšuje její robustnost.

Mezi silné nevýhody této architektury patří zvýšená bezpečnostní rizika způsobená tím,
že klienti jsou otevřeni komunikaci s jakýmkoliv jiným, potenciálně nebezpečným, klientem.
Potenciální útočník tak může velmi snadno využít zranitelností na dálku.
Další hrozbou je to, že některý z klientů může \textit{otrávit} síť podvrženými daty.
Podstatnou nevýhodou může být absence jakékoliv centrální správy sdílených dat.

Ačkoliv se může \gls{P2P} jevit jako vhodný přístup pro sdílení byznysových pravidel
díky svojí orientaci na sdílení dat, vysoké datové propustnosti a robustnosti, právě absence
centrální správy by mohla uvrhnout systém do nekonzistentního stavu při úpravě či přidání
byznysového pravidla. Tato architektura totiž implikuje, že by byznysové pravidlo bylo
replikováno a distribuováno mezi více uzlů sítě. Změna pravidla by se tak musela šířit postupně
napříč systémem, přičemž některé uzly by stále využívaly starou verzi pravidla, a nad samotným
šířením by neměl administrátor systému kontrolu.

\subsection{Representational state transfer}\label{sec:rest}

Representational state transfer~\cite{fielding2000rest} (\gls{REST}) je architektura
webových služeb, která staví na protokolu \gls{HTTP}, a klade na systém
několik architektonických omezení, díky kterým může systém dosáhnout
lepšího výkonu, vyšší škálovatelnosti, jednoduchému používání díky jednotnému rozhraní
a lepší odolnosti vůči chybám. V roce 2000 ho ve své dizertační práci představil Roy Fielding,
který je zároveň hlavním autorem specifikace \gls{HTTP} 1.1~\cite{fielding1999hypertext}.

\gls{REST} chápe data systému jako množinu zdrojů (z anglického \textit{resources}),
nad kterými jsou prováděny operace pomocí \gls{HTTP} požadavků. K odlišení operací
nad jedním zdrojem jsou využívány slovesa protokolu \gls{HTTP}, zejména pak \code{GET} pro čtení,
\code{POST} pro vytváření, \code{PUT} pro úpravu a \code{DELETE} pro mazání. Tím jsou zastřešeny
všechny \gls{CRUD} operace.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.9\linewidth]{figures/rest-statelessness.pdf}
    \caption{Znázornění architektury \gls{REST}}
    \label{fig:rest-statelessness}
\end{figure}

Principy architektury \gls{REST} jsou:

\begin{description}
    \item [Klient-server] Systém by měl využívat model klient-server. Díky tomu může jasně rozdělit
    zodpovědnost za uživatelské rozhraní na klienta a zodpovědnost za ukládání dat na server. Díky tomu se zvyšuje
    škálovatelnost systému díky nižším nárokům na server.
    \item [Bezstavovost] Každý požadavek na server by měl obsahovat všechny informace potřebné k jeho vykonání.
    Kromě těla \gls{HTTP} požadavku se k tomuto účelu často využívají i hlavičky požadavku,
    například hlavička \code{Authorization} pro autentizaci uživatele kvůli přístupu k zabezpečeným zdrojům.
    Tím se zjednodušuje komplexita serveru, který plně přesouvá zodpovědnost za uchování stavu uživatelského rozhraní
    na klienta, jak je znázorněno na obrázku~\ref{fig:rest-statelessness}. Nutno poznamenat, že stav dat v systému
    je stále uchováván na serveru.
    \item [Kešování] Odpovědi serveru musí obsahovat explicitní informaci o tom, zda lze odpověď uložit do cache.
    Díky tomu lze znovupoužívat data, která již server jednou vrátil, a jejich životnost má dlouhodobější charakter.
    Tím se zvyšuje výkon celého systému.
    \item [Vrstvený systém] Klient by neměl mít možnost rozeznat, zda komunikuje přímo se serverem, nebo s prostředníkem,
    např. s proxy serverem, load balancerem nebo cache.
    \item [Code-on-demand] Volitelným požadavkem na systém je tzv. \textit{code-on-demand}, který umožňuje serveru vracet
    spustitelný kód jako odpověď. Klient kód poté spustí na své straně. Typickým příkladem jsou klientské JavaScriptové aplikace spouštěné ve webových prohlížečích.
    \item [Jednotné rozhraní] Zdroje systému musejí mít unikátní identifikátor, např. \gls{URI}. Zdroje jsou při komunikaci reprezentovány libovolným formátem, který
    se může lišit od interní reprezentace zdroje v programu, např. \gls{JSON} či \gls{XML}. Reprezentace zdroje musí být
    dostatečná k tomu, aby šlo na zdroji provést úpravu či smazání. Zprávy mezi klientem a serverem musejí obsahovat veškerá potřebná metadata,
    aby druhá strana mohla zprávu plně zpracovat. K tomu se používají například \gls{HTTP} hlavičky \code{Content-type}
    či \code{Accept}, ve kterých je popsán typ reprezentace zdroje.
    Rozhraní by také mělo dodržovat koncept \textit{Hypermedia as the engine ot application state (\gls{HATEOAS})},
    který vyžaduje, aby server v odpovědích vracel metainformace o struktuře jeho \gls{API}.
    Klient je tak schopen dynamicky navigovat v rozhraní serveru aniž by bylo vyžadováno předem znát přesné adresy zdrojů.
    Princip \gls{HATEOAS} se však ve většině reálných \gls{API} zanedbává či implementuje pouze částečně
\end{description}

Nevýhody architektury \gls{REST} spočívají zejména v náročnosti její korektní implementace,
která se v praxi často zjednodušuje a tím degraduje její výhody. Přes rošířenost a popularitu
této architektury ji stále mnoho vývojářů nezná do detailu a zanedbávají některé její části.
Většina programovacích jazyků je založena na volání funkcí či metod, což svádí vývojáře ke
špatnému návrhu systému. \gls{REST} totiž naopak vyžaduje od vývojáře nad systémem přemýšlet jako
nad množinou zdrojů. Jinou nespornou nevýhodou je náročná implementace transakcí, které zahrnují více
zdrojů najednou. Protokol \gls{HTTP} nepodporuje uzavření více požadavků do jedné atomické
transakce. To může být problém v \gls{SOA} zejména pokud je vyžadována kooperace více služeb
najednou při vykonávání byznysové operace. Existují však koncepty, které využívají model
Try-Cancel/Confirm~\cite{pardon2011towards}, umožňující zajistit atomické transakce nad \gls{REST} architekturou.
Jak jsme již zmínili v sekci~\ref{sec:microservices}, moderní systémy se přiklánějí ke konceptu
\textit{eventual consistency}, kdy jsou tolerovány drobné nekonzistence, které jsou nakonec
dořešeny manuálně, pokud je cena za ně menší než cena za implementaci systému, který
by plně podporoval atomické transakce.

\subsection{Remote procedure call}\label{sec:rpc}

Remote procedure call (\gls{RPC}) je podstatně starší architekturou než \gls{REST}.
Tento termín byl použit již v roce 1981 Brucem Nelsonem~\cite{nelson1981remote}.
Architektura staví na modelu klient-server a její princip je velmi jednoduchý \textendash
umožňuje jednomu procesu, klientovi, zavolat proceduru na druhém, vzdáleném procesu, tedy serveru.
Klient zašle serveru zprávu, která vyžádá zavolání specifické procedury. Server
proceduru provede a po jejím dokončení zašle klientovi odpověď s návratovou hodnotou.
Klient poté může pokračovat ve své práci.

Zásadním bodem je fakt, že \gls{RPC} kompletně obstarává komunikaci, a v programu samotném
je vzdálená procedura volána stejným způsobem jako lokální procedury. Základním
prvkem architektury na klientovi i na serveru je tzv. \textit{stub}, tedy komponenta, která
umožňuje volat vzdálenou proceduru lokálně a zapozdřuje veškerou síťovou komunikaci
a serializaci či deserializaci argumentů, resp. návratových hodnot. Schéma komunikace
je znázorněno na obrázku~\ref{fig:rpc}.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.7\linewidth]{figures/rpc.pdf}
    \caption{Schéma komunikace \gls{RPC}}
    \label{fig:rpc}
\end{figure}

Představitelem architektury \gls{RPC} je například technologie \gls{CORBA},
kterou jsme již popsali v sekci~\ref{sec:corba}, nebo technologie Remote Method Invocation (\gls{RMI})
v jazyce Java. Modernějším pojetím je technologie gRPC~\cite{grpcio}
od společnosti Google\footnote{https://www.google.com/},
která je v dnešní době hojně využívána úspěšnými technologickými společnostmi.

Již zmiňovanou nevýhodou abstrakce lokálních a vzdálených volání jsou
negativní vlastnosti síťové komunikace, tedy její zvýšená latence
a nižší robustnost. Pokud programátor nemá možnost zjistit, zda volá
lokální či vzdálenou proceduru, výsledný kód může být těžké optimalizovat
a správně ošetřit výjimky, které mohou při jeho běhu nastat.

Na druhou stranu, narozdíl od \gls{REST} není pro \gls{RPC} potřeba
implementovat komplexní middleware obstarávající síťovou komunikaci,
serializaci a zpracování chyb. Middleware je zpravidla dodáván v podobě knihoven
dané technologie. Některé systémy a jejich případy použití mohou být snadněji
realizovány jako volání procedury než jako entita reprezentující systémový zdroj.

Vhodnost \gls{RPC} architektury pro distribuci a správu byznysových pravidel je do značné
míry ovlivněna tím, jakou konkrétní technologii využijeme. Stejně jako \gls{REST}
ani \gls{RPC} nedefinuje jakým způsobem by měly být obslouženy transakce. Byli bychom tedy
nuceni si transakční systém doimplementovat. To by však mohlo být o něco snažší díky tomu,
že by obsluha transakce mohla být volána jako procedura, a tím bychom si ušetřili práci
s obslužným kódem.

\section{Aspektově orientované programován\'{\i}}\label{sec:aop}

\goal{Co je paradigma}
Programován\'{\i} je komplexn\'{\i} discipl\'{\i}na s teoreticky
neomezen\'ym počtem možnost\'{\i}, jak\'ym programátor může
řešit zadan\'y problém. Ačkoliv každá úloha má své specifické
požadavky, za relativně krátkou historii programován\'{\i} se
stihlo ustálit několik ideologi\'{\i}, tzv. programovac\'{\i}ch
paradigmat, které programátorovi poskytuj\'{\i} sadu abstrakc\'{\i}
a základn\'{\i}ch principů~\cite{van2009programming}.
D\'{\i}ky znalosti paradigmatu může programátor nejen zlepšit
svou produktivitu, ale zároveň může snáze pochopit myšlenky
jiného programátora a t\'{\i}m zlepšit kvalitu t\'ymové spolupráce.

\goal{OOP a jeho popis}
Jedn\'{\i}m z nejpopulárnějš\'{\i}ch paradigmat použ\'{\i}van\'ych k
v\'yvoji modern\'{\i}ch enterprise systémů je nepochybně
objektově orientované programován\'{\i} (\gls{OOP}). To vn\'{\i}má dan\'y problém
jako množinu objektu, které spolu intereaguj\'{\i}. Program
člen\'{\i} na malé funkčn\'{\i} celky odpov\'{\i}daj\'{\i}c\'{\i} struktuře
reálného světa~\cite{rentsch1982object}. Je vhodné zm\'{\i}nit,
že objekty se rozum\'{\i} jak konkrétn\'{\i} koncepty, např\'{\i}klad
auto nebo člověk, tak i abstraktn\'{\i} koncepty,
namátkou bankovn\'{\i} transakce nebo objednávka v obchodě.
Objekty se pak prom\'{\i}taj\'{\i} do kódu programu i do
reprezentace struktur v paměti poč\'{\i}tače.
Tento př\'{\i}stup je velmi snadn\'y pro pochopen\'{\i},
vede k lepš\'{\i}mu návrhu a organizaci programu a snižuje
tak náklady na jeho v\'yvoj a údržbu.

\goal{Nedostatky OOP}
Ačkoliv je \gls{OOP} velmi siln\'ym a všestrann\'ym nástrojem,
existuj\'{\i} problémy, které nelze jeho pomoc\'{\i} efektivně řešit.
Jedn\'{\i}m takov\'ym problémem jsou obecné požadavky na systém,
které musej\'{\i} b\'yt konzistentně dodržovány na v\'{\i}ce m\'{\i}stech,
které spolu zdánlivě nesouvis\'{\i}. Př\'{\i}kladem
může b\'yt logován\'{\i} systémov\'ych akc\'{\i}, optimalizace správy paměti
nebo uniformn\'{\i} zpracován\'{\i} v\'yjimek~\cite{kiczales1997aspect},
ale i aplikace byznysových pravidel~\cite{cemus2014aspect}.
Takové požadavky naz\'yváme \textit{průřezové problémy}
(z anglického \textit{cross-cutting concerns}).
V rámci \gls{OOP} je programátor nucen v ojektech manuálně opakovat
kód, kter\'y zodpov\'{\i}dá za jejich realizaci. Duplikace kódu
vede k větš\'{\i} náchylnosti na lidskou chybu a k vyšš\'{\i}m nárokům na v\'yvoj
a údržbu daného softwarového systému~\cite{fowler1999refactoring}.

\goal{AOP jako odpověď na nedostatky OOP}
Aspektově orientované programován\'{\i} (\gls{AOP}) přináš\'{\i} řešen\'{\i} na
v\'yše zmiňované problémy. Extrahuje obecné požadavky,
tzv. \textit{aspekty} do jednoho m\'{\i}sta a pomoc\'{\i} procesu zvaného
\textit{weaving} je poté automaticky distribuuje do systému.
Weaving může proběhnout staticky při kompilaci programu nebo dynamicky
při jeho běhu. V obou př\'{\i}padech ale programátorovi ulehčuje práci,
protože k definici i změně aspektu docház\'{\i} centrálně a t\'{\i}m je eliminována
potřeba manuáln\'{\i} duplikace kódu. Je nutno poznamenat, že \gls{AOP} nen\'{\i}
paradigmatem poskytuj\'{\i}c\'{\i}m kompletn\'{\i} framework pro návrh programu.
V ideáln\'{\i}m př\'{\i}padě je tedy k návrhu systému využita kombinace
\gls{AOP} s jin\'ym paradigmatem. Pro účely této práce se zaměř\'{\i}me na
kombinaci \gls{AOP} a \gls{OOP}.

\todo{
\begin{itemize}
    \item diagram cross cutting concerns
    \item roztáhnout do v\'{\i}ce odstavců
    \item diagram weaveru
    \item section BPEL
\end{itemize}
}

\begin{description}
    \item [Aspekt]
    \item [Join-point]
    \item [Pointcut]
    \item [Advice]
    \item [Weaving]
\end{description}

\section{Aspect-driven Design Approach}

\todo{
\begin{itemize}
    \item co to je
    \item jak nám to pomůže
    \item využ\'{\i}t\'{\i} jeho konceptů
    \item shrnut\'{\i}
\end{itemize}
}

Aspect-driven Design Approach (\gls{ADDA})

\goal{Vhodnost AOP pro náš úkol}
Vzhledem k požadavkům na implementaci našeho frameworku stanoven\'ym
v předchoz\'{\i} kapitole~\ref{ch:analyza} se \gls{AOP} a na něm stavěj\'{\i}c\'{\i} \gls{ADDA}
jev\'{\i} jako vhodn\'y př\'{\i}stup, kter\'y nám pomůže dosáhnout c\'{\i}le.

\section{Stávaj\'{\i}c\'{\i} řešen\'{\i} reprezentace business pravidel}

\subsection{Drools DSL}

Framework Drools~\cite{drools} vyvijený společností JBoss\footnote{http://www.jboss.org/}
je open-source projekt realizující \textit{business rule management engine} (\gls{BRMS}),
tedy nástroj pro vývoj a správu byznysových pravidel. Framework umožňuje realizovat
tzv. \textit{produkční systémy}, tedy systémy tvořené sadou \textit{produkčních pravidel}
určujících chování programu. Tato pravidla obsahují popis situace a její řešení v případě,
že nastane. Jedná se tedy o formu umělé inteligence.

Produkční pravidlo se skládá z levé strany (\gls{LHS} z anglického \textit{left-hand side}),
a z pravé strany (\gls{RHS} z anglického \textit{right-hand side}),
\gls{LHS} popisuje situaci, při které má být pravidlo aplikováno. \gls{RHS} popisuje akci,
která má být vykonána.

Pro správnou funkci systému je nutno při vyhodnocování správně určit, která produkční pravidla
mají být aplikována. Pro tento účel využívá frameowkr Drools algoritmus RETE~\cite{forgy1988rete},
který je přímo navržený pro párování pravidel produkčních systémů.

Součástí frameworku Drools je i speciální doménově specifický jazyk vyvinutý přímo
pro modelování produkčních pravidel.

Ve zdrojovém kódu~\ref{lst:drools-example} můžeme vidět příklad zápisu
byznysového pravidla v jazyce Drools DSL. Kromě názvu pravidla je v hlavičce
uvedeno, které dialekty jsou v pravidle využity. Dialekt \code{MVEL} je součástí
Drools \gls{DSL} a slouží pro zápis \gls{LHS} i \gls{RHS}. Dialekt \code{java}
nám umožňuje pro \gls{RHS} využít přímo jazyk Java.

%\todo{
%\begin{itemize}
%    \item co to je
%    \item jak to funguje
%    \item RETE algoritmus
%    \item v\'yhody
%    \item nev\'yhody
%    \item shrnut\'{\i} a proč se nám nehod\'{\i}
%\end{itemize}
%}
%
%\goal{Drools se nám nehod\'{\i}, protože je jen pro platformu Java}
%...

\lstinputlisting[
caption={Ukázka zápisu byznysového pravidla v jazyce Drools DSL},
label={lst:drools-example},
language=Drools,
%frame=single,
%float,
%floatplacement=H
]
{code/drools_example.drl}

Ačkoliv je jazyk Drools \gls{DSL} vymodelovaný přímo pro zápis pravidel doménovými experty,
odlišnost produkčních pravidel a byznysových pravidel tak, jak jsme si je zavedli v sekci~\ref{sec:business-rules}
je na první pohled zřejmá. Pro naše účely bychom využili pouze \gls{LHS}, protože nám stačí
popsat nastalou situaci, ale o následnou akci se postará systém \textendash v případě
precondition je byznysová operace zastavena, v případě post-condition je aplikován filtr
na všechny proměnné splňující danou podmínku. Zároveň jazyk Drools \gls{DSL} postrádá
nástroje pro kvalitní popis byznysového kontextu držícího byznysová pravidla,
zejména pak rozšiřování jiných kontextů a popis typu jednotlivých pravidel.
V neposlední řadě nejsou ze strany frameworku Drools podporovány jiné platformy než
Java a .NET, což nevyhovuje našim požadavkům na platformovou nezávislost.

\subsection{JetBrains MPS}

Zajímavým nástrojem z dílny společnosti JetBrains\footnote{https://www.jetbrains.com/}
je tzv. \textit{MPS \textendash\xspace Meta Programming System}~\cite{jetbrainsmps}, který si klade za úkol být univerzálním
nástrojem pro tvorbu doménově specifických jazyků. Staví na konceptu \textit{language-oriented
programming} (\gls{LOP})~\cite{ward1994language}, který se zaměřuje na vývoj velmi specifického jazyka,
který je následně použit pro implementaci programu namísto obecného mnohoúčelového jazyka. Pro překlad
ze specifického jazyka do spustitelného kódu je použit automatický překladač. Příkladem jazyka, který využívá koncept \gls{LOP}
je \LaTeX\xspace, který byl využit pro sazbu této diplomové práce. Ten totiž pomocí maker jazyka \TeX\xspace
sestavuje abstraktnější jazyk, který umožňuje autorovi soustředit se hlavně na strukturu textu, aniž by
se musel příliš detailně zaobírat samotnou sazbou.

MPS umožňuje uživateli nadefinovat gramatiku speciálního \gls{DSL} a následně poskytuje
editor pro tento jazyk včetně validace. MPS podporuje také transformování kódu napsaného
v nadefinovaném jazyce do jiných nízkoúrovňovějších jazyků, zejména pak do jazyka Java.
Díky tomu lze nejen vytvářet libovolné \gls{DSL}, ale také rozšiřovat existující
jazyky \textendash například přidat do jazyka Java podporu pro jednoduchý vizuální zápis matic.

Výhoda tohoto přístupu je podobně jako u \gls{MDA} vysoká úroveň abstrakce, která
velmi dobře odděluje problém návrhu systému od implementačních problémů.
Navíc lze díky použití \gls{DSL} zapojit do vývoje doménové experty a snížit tak
zátěž na programátory, kteří se mohou více věnovat právě implementačním problémům.
\gls{DSL} typicky zvyšuje expresivitu kódu a díky tomu se zmenšuje jeho objem.
Nižší objem kódu vede ke snížení nákladů na jeho údržbu a vývoj~\cite{littman1987mental}\cite{soloway1986empirical}.
Významnou výhodou MPS, potažmo \gls{LOP}, je vysoká portabilita vyvinutého jazyka.
Pro migraci na jinou platformu stačí doprogramovat překladač jazyka, ale
samotný jazyk může zůstat zachovaný.

Z výčtu výhod plyne, že bychom mohli MPS využít k popisu byznysových pravidel,
resp. byznysových kontextů. Tím bychom získali silný aparát k zachycení a
znovupoužití pravidel a jejich transformaci do neomezeného počtu jazyků pro
využití na mnoha platformách. Podobně jako u \gls{MDA} je však problém v dopředném
generování \textendash pro případ úpravy pravidla za běhu programu bychom museli
nějakým způsobem upravované pravidlo přetransformovat z dané platformy zpět
do našeho \gls{DSL}, upravit ho pomocí editoru MPS, a následně ho opět přeložit
do spustitelného jazyka pro danou platformu. To by vyžadovali potřebu překompilovat
a znovunasadit všechny služby využívající dané pravidlo.

\section{Shrnut\'{\i}}

V této kapitole jsme provedli rešerši \textit{modelem řízené architektury},
jej\'{\i}ch v\'yhod a nev\'yhod. Dále jsme prozkoumali, jak\'y způsobem funguje
s\'{\i}ťová \textit{architektura klient-server}, jaké jsou v\'yhody a nev\'yhody
a shrnuli jsme paradigma \textit{aspektově orientovaného programován\'{\i}} a
z něch vycházej\'{\i}c\'{\i} př\'{\i}stup k návrhu softwarov\'ych systémů \textit{ADDA}.
Nakonec jsme provedli rešerši stávaj\'{\i}c\'{\i}ch řešen\'{\i} reprezentace byznys pravidel
včetně komplexn\'{\i}ho frameworku \textit{Drools} a zhodnotili jsme jeho vhodnost
k řešen\'{\i} našeho problému. % TODO: revize podle toho co tu opravdu bude
