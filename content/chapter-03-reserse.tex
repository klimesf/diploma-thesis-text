%!TEX ROOT=../diploma-thesis.tex

\chapter{Rešerše}\label{ch:reserse}

Tato kapitola se věnuje rešerši existujících řešení
a výzkumu relevantnímu k tématu této práce. Díky tomu bude umožněno
dosáhnout kvalitního a efektivního návrhu frameworku pro centrální správu a automatickou
distribuci byznysových pravidel.
Kapitola zkoumá modelem řízenou architekturu, generativní
programování a BPEL, jejich výhody, nevýhody a vhodnost použití.
Dále se zaměřuje na aspektově orientované programování
a na něm založený inovativní přístup k návrhu informačních systémů \gls{ADDA}.
Kapitola také zkoumá existující nástroje a specializované jazyky pro vyjádření
byznysových pravidel.
Nakonec se věnuje i shrnutí síťových architektur, které mohou být využity
pro automatickou distribuci byznysových pravidel v \gls{SOA}.

\section{Modelem ř\'{\i}zená architektura}

Modelem řízená architektura (\gls{MDA} z anglického \textit{Model-Driven
Architecture}) se zaměřuje na návrh \gls{IS} s využitím modelů a jejich
následnou transformaci do spustitelného kódu pomocí generativních nástrojů~\cite{soley2000model}.
Hlavní výhodou \gls{MDA} je vysoká úroveň abstrakce, která zbavuje vývojáře nutnosti
manuálně duplikovat informace. Další výhodou je nezávislost na platformě a zvýšení
kvality kódu díky jeho automatickému generování.

%Autorem specifikací \gls{MDA} je konsorcium Object Modeling Group (\gls{OMG}),
%které se zaměřuje na standardizaci modelovacích standardů pro software
%a stojí za modelovacím jazykem \gls{UML}, který je de facto globálním standardem
%pro vizualizaci statických i dynamických aspektů softwarových systémů.

\gls{MDA} využívá Computation Independent Model (\gls{CIM}), který reprezentuje
řešení nezávislé na použitých výpočetních metodách a algoritmech. Z \gls{CIM} je
model převeden do Platform Independent Model (\gls{PIM}),
který popisuje koncepci systému bez ohledu na implementační detaily, typicky k popisu
využívá jazyk \gls{UML}. \gls{PIM} je následně převeden do
Platform Specific Model (\gls{PSM}), tedy modelu využívajícího
specifických aspektů platformy, pro kterou má být systém postaven.
\gls{PIM} může být převeden na jeden či více \gls{PSM}.
Nakonec je \gls{PSM} transformován do spustitelného kódu.

Hlavní nevýhodou \gls{MDA}, která zabraňuje jejímu využití
pro účel této práce, je jednosměrný dopředný proces, kterým je výsledný kód generován.
Pokud dojde ke změně požadavků, která se promítne do modelu, je potřeba přegenerovat
kód celého systému. Kód, který bylo nutno doplnit ručně, může snadno zastarat a je tak
potřeba ho manuálně projít a opravit.
%Změna byznysových pravidel v našem případě by
%navíc při využití \gls{MDA} vyžadovala znovu-nasazení celého
%systému, což je v přímém rozporu s požadavkem na možnost dynamicky
%upravovat či přidávat byznysová pravidla za běhu systému.
Další nevýhodou tohoto přístupu je jeho závislost na \gls{OOP},
které samotné není schopné se efektivně vypořádat s průřezovými
problémy~\cite{cemus2014aspect}, jak si popíšeme v sekci~\ref{sec:aop}.
%Ačkoliv je \gls{MDA} známá již od roku 2000, generativní nástroje pro
%její podporu jsou stále nevyspělé a pro některé platformy úplně chybí.

\section{Generativní programování}

Generativní programování (\gls{GP}) je dalším příkladem paradigmatu, který
využívá vyšší úroveň abstrakce a díky tomu zvýšuje znovupoužitelnost
kódu. \gls{GP} se zaměřuje na maximalizaci automatizace vývoje systému
skrz generování a syntézu vysoce přizpusobitelných komponent. Vývojář
popíše komponentu v abstraktním jazyce přizpůsobeném doméně řešeného
problému a generátor se postará o její automatické vytvoření~\cite{czarnecki2000generative}.
Díky tomu je možné oddělit popis jednotlivých vlastností systému a dosáhnout tak
jejich vysoké znovupoužitelnosti.

\gls{GP} by mohlo být využito pro abstrakci bynysových pravidel a jejich automatickému
začleňování do kódu služeb v systému stavějícím na \gls{SOA}.
Statické generování komponent však nesplňuje požadavek na dynamickou správu
byznysových pravidel za běhu systému.

\section{Business Process Execution Language}

\gls{BPEL}

\todo{
\begin{itemize}
    \item Co to je
    \item Jak to funguje
    \item Výhody a nevýhody
\end{itemize}
}

\section{Objektově orientované programování}\label{sec:oop}

\goal{OOP a jeho popis}
Jedn\'{\i}m z nejpoužívanějších paradigmat používaných k
v\'yvoji modern\'{\i}ch \gls{IS} je objektově orientované programován\'{\i} (\gls{OOP}).
To používá koncept tzv. objektů, které zapouzdřují data a funkcionalitu do
malých funkčních celků odpov\'{\i}daj\'{\i}c\'{\i} struktuře reálného světa~\cite{rentsch1982object}.
Objekty se rozum\'{\i} jak konkrétn\'{\i} koncepty, např\'{\i}klad auto nebo člověk, tak i
abstraktn\'{\i} koncepty, jako je bankovn\'{\i} transakce nebo objednávka v obchodě.
Podoba objektů se pak prom\'{\i}tá do kódu programu i do reprezentace struktur v paměti
poč\'{\i}tače. Tento př\'{\i}stup je velmi snadn\'y pro pochopen\'{\i},
vede k lepš\'{\i}mu návrhu a organizaci programu a snižuje
tak náklady na jeho v\'yvoj a údržbu.

Vlastnosti \gls{OOP} jako je zapouzdření, dědičnost a polymorfismus přináší
vysokou znovupoužitelnost kódu, nižší riziko lidské chyby, zjednodušení
návrhu systému a nižší náklady na vývoj a údržbu software.

\section{Aspektově orientované programován\'{\i}}\label{sec:aop}



\subsection{Motivace}

%\goal{Co je paradigma}
%Programován\'{\i} je komplexn\'{\i} discipl\'{\i}na s teoreticky
%neomezen\'ym počtem možnost\'{\i}, jak\'ym programátor může
%řešit zadan\'y problém. Ačkoliv každá úloha má své specifické
%požadavky, za relativně krátkou historii programován\'{\i} se
%stihlo ustálit několik ideologi\'{\i}, tzv. programovac\'{\i}ch
%paradigmat, které programátorovi poskytuj\'{\i} sadu abstrakc\'{\i}
%a základn\'{\i}ch principů~\cite{van2009programming}.
%D\'{\i}ky znalosti paradigmatu může programátor nejen zlepšit
%svou produktivitu, ale zároveň může snáze pochopit myšlenky
%jiného programátora a t\'{\i}m zlepšit kvalitu t\'ymové spolupráce.

\goal{Nedostatky OOP}
Ačkoliv je \gls{OOP} velmi siln\'ym nástrojem, existuj\'{\i} problémy,
které nelze v jeho rámci efektivně řešit.
Příkladem takového problému jsou obecné požadavky na systém,
které musej\'{\i} b\'yt konzistentně dodržovány na v\'{\i}ce
m\'{\i}stech systému, které spolu zdánlivě nesouvis\'{\i},
tzv. \textit{průřezové problémy} (z anglického \textit{cross-cutting concerns}).
V rámci \gls{OOP} je programátor nucen v ojektech manuálně opakovat
kód, kter\'y zodpov\'{\i}dá za jejich realizaci. Duplikace kódu
vede k větš\'{\i} náchylnosti na lidskou chybu a k vyšš\'{\i}m nárokům na v\'yvoj
a údržbu daného softwarového systému~\cite{fowler1999refactoring}.
Obrázek~\ref{fig:cross-cutting} znázorňuje vzájemné postavení průřezových
problémů a komponent informačního systému.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.35\linewidth]{figures/cross-cutting.pdf}
    \caption{Průřezové problémy v informačních systémech}
    \label{fig:cross-cutting}
\end{figure}

\goal{Konkrétní příklad nedostatku OOP}
Př\'{\i}kladem průřezového problému může b\'yt logován\'{\i}
systémov\'ych akc\'{\i}, optimalizace správy paměti
nebo jednotné zpracován\'{\i} v\'yjimek~\cite{kiczales1997aspect},
ale i aplikace byznysových pravidel~\cite{cemus2014aspect}.
%Uvažme e-commerce systém a zpracování transakcí. To musí
%být zohledněno jak při vytváření objednávek, tak při registraci
%nového uživatele \textendash\xspace dvě byznysové akce, které by měly
%být podle \gls{OOP} implementovány v naprosto odlišných objektech
%a striktně odděleny, ale část jejich funkcionality je identická,
%a tudíž dochází k duplikaci kódu.
Ve zdrojovém kódu~\ref{lst:tangling} je znázorněno, jak průřezové
problémy zasahují do kódu imaginární třídy implementované v
jazyce Java, která slouží pro vytváření objednávek v e-commerce
systému popsaném v sekci~\ref{sec:shortcomings}.
Aspekt logování je zohledněn na třech místech, stejně jako aspekt transakcí.
Navíc jsou zde zohledněna i byznysová pravidla pro validaci doručovací
a fakturační adresy objednávky.

\lstinputlisting[
caption={Příklad průřezových problémů zohledněných při vytváření objednávky},
label={lst:tangling},
language=Java,
%frame=single,
float,
floatplacement=t
]
{code/tangling.java}

\subsection{Vlastnosti}
Aspektově orientované programován\'{\i} (\gls{AOP}) přináš\'{\i} řešen\'{\i}
v\'yše zmiňovaných problémů. Využívá k tomu \textit{separation of concerns} \textendash\xspace
extrahuje kód zachycující průřezové problémy, tzv. \textit{aspekty}, do jednoho bodu, tzv. (\textit{single focal point}).
Pomoc\'{\i} procesu zvaného \textit{weaving} je poté tento kód automaticky distribuován.
Weaving může proběhnout staticky při kompilaci programu nebo dynamicky
při jeho běhu. V obou př\'{\i}padech ale programátorovi ulehčuje práci,
protože k definici i změně aspektu docház\'{\i} centrálně, a t\'{\i}m je eliminována
potřeba manuáln\'{\i} duplikace kódu. \gls{AOP} nen\'{\i} paradigmatem poskytuj\'{\i}c\'{\i}m
kompletn\'{\i} framework pro návrh programu. V ideáln\'{\i}m př\'{\i}padě je tedy k návrhu
systému využita kombinace \gls{AOP} s jin\'ym paradigmatem.
%Tato práce se zaměř\'{\i}uje na kombinaci \gls{AOP} a \gls{OOP}.

\subsection{Názvosloví}

\paragraph{Aspekt}
Základním pojmem v rámci \gls{AOP} je \textit{aspekt},
který zapozdřuje průřezovou funkcionalitu a zároveň adresuje místa, kde má být
funkcionalita aplikována. Aspekt vždy obsahuje alespoň jeden \textit{advice}
a jeden \textit{pointcut}.

\paragraph{Join-point}
Místo v kódu, na které může být aplikována funkcionalita aspektu, se nazývá
\textit{join-point}. Typů join-pointů je více a závisí na použitém paradigmatu,
na který je \gls{AOP} aplikováno, a také na programovacím jazyce. V případě
kombinace s \gls{OOP} a klasickým víceúčelovým jazykem jako je například Java,
mohou jako join-pointy sloužit konstruktory tříd, volání metod, zápis a čtení
z atributu objektu, inicializace třídy nebo objektu a mnoho dalších.

\paragraph{Pointcut}
Ne každý aspekt je aplikován na každý join-point. Množina join-pointů,
na které je jeden konkrétní aspekt aplikován, se nazývá \textit{pointcut}.
Tato množina může být určena staticky, a být tak známá při kompilaci programu, nebo
dynamicky za běhu programu, což přináší výpočetní složitost navíc.
Dynamické určení pointcutu ale umožňuje vývojářům postihnout i případy,
kdy nelze předem jasně určit místa, kde má být aspekt začleněn.
Příkladem může být zpracování transakcí v zanořených byznysových operacích,
kdy transakce má být započata pouze při vstupu do vnější operace
a dokončena pouze při výstupu z vnější operace.

\paragraph{Advice}
Funkcionalita, kterou aspekt přidává v jeho pointcutu, se nazývá
\textit{advice}. Existuje více typů advice, podle toho, kam je
daná funkcionalita přidána. Například při volání metody může
být funkcionalita přidána před, za, nebo kolem metody.

\paragraph{Weaving}
Proces, kterým jsou advice začleňovány podle pointcutu do
jednotlivých join-pointů se nazývá \textit{weaving}. Ten může
probíhat již při kompilaci nebo dynamicky za běhu programu,
tzv. \textit{run-time weaving}. Proces weavingu je ilustrován
na obrázku~\ref{fig:aspect-weaving}. Komponenta zodpovědná za
weaving se nazývá \textit{aspect weaver}.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.7\linewidth]{figures/aspect-weaving.pdf}
    \caption{Proces weavingu aspektů}
    \label{fig:aspect-weaving}
\end{figure}

\section{Aspect-driven Design Approach}

Alternativním způsobem návrhu informačních systémů, který staví na principech \gls{AOP},
je Aspect-driven Design Approach\footnote{Autoři nejprve používali termín \textit{Aspect-Oriented
Design Approach} (AODA), který byl později změněn. Oba tyto pojmy jsou vzájemně zaměnitelné.}
(\gls{ADDA})~\cite{cemus2014aspect}, představený v roce 2014.
Tento přístup se zaměřuje na formalizaci jednotlivých komponent informačních systémů identifikování aspektů
v informačních systémech a jejich separaci do \textit{single focal point}.
Následně přístup využívá weaving pro automatickou distribuci aspektů do systému.
K popisu aspektu doporučuje využití doménově specifického jazyka, který bude navržen na
míru danému průřezovému problému.

\subsection{Možnosti aplikace}

Autoři \gls{ADDA} aplikovali tento koncept v několika oblastech \gls{IS}.
Mezi tyto oblasti patří automatické začleňování byznysových pravidel
do datové vrstvy informačních systémů~\cite{cemus2015automated}, automatické
generování uživatelských rozhraní citlivých na kontext uživatele~\cite{cemus2017separation},
validaci vstupů formulářů v uživatelském rozhraní vůči byznysovým pravidlům~\cite{cemus2016context}\cite{cemus2017separation}
a automatické extrakci dokumentace~\cite{cemus2017automated}.

\paragraph{Automatické začleňování byznysových pravidel do datové vrstvy}

Jednou z možných aplikací přístupu \gls{ADDA} je automatické začleňování
byznysových pravidel do datové vrstvy \gls{IS}\footnote{Předpokládáme standardní
třívrstvou architekturu informačních systémů~\cite{fowler2002patterns}}.
Byznysová pravidla jsou nejprve vhodně popsána pomocí \gls{DSL} a následně jsou
extrahována do jednoho bodu, ze kterého jsou automaticky distribuována.
Pomocí specializovaného weaveru jsou pravidla překládána do podmínek
jazyka \gls{JPQL}, potažmo \gls{SQL}, který je využíván k získávání dat
z databázových systémů. To vede ke snížení manuální duplikace byznysových
pravidel.

\paragraph{Automatické generování uživatelského rozhraní}

Uživatelská rozhraní tvoří až 48 \% kódu informačních systému
a zabírají až 50 \% jejich vývojového času~\cite{kennard2009separation}.
Do \gls{UI} se přitom typicky promítá mnoho aspektů, které jsou
již v systému obsaženy, a vývojáři je musí manuálně duplikovat.
Typickým příkladem je struktura datového modelu, která se promítá
zejmána do struktury formulářů sloužících pro manipulaci s daty systému.
Byznysová pravidla jsou promítána do \gls{UI} při validaci vstupních
dat formulářů na straně klienta~\cite{cemus2017separation}.
Dalšími příklady může být lokalizace \gls{UI} do různých jazyků
nebo rozložení a stylizace jednolivých ovládacích prvků, která
je zpravidla uniformní v celém systému.

Autoři přístupu \gls{ADDA} přicházejí s řešením v podobě
využití několika \gls{DSL} pro popis jednotlivých aspektů
a run-time weavingu, který aspekty při běhu aplikace
dynamicky začlení do \gls{UI} s ohledem na aktuální kontext
uživatele, například na jeho geolokační polohu či velikost
displeje, na kterém je rozhraní zobrazováno.
Díky tomu je dosaženo významné redukce kódu~\cite{cemus2016context}
potřebného pro popis adaptibilního uživatelského rozhraní
a tím jsou ušetřeny náklady na vývoj a údržbu informačního
systému využívajícího tento přístup.

\paragraph{Automatická extrakce dokumentace}

Další oblastí informačních systému, do které se promítají jeho aspekty,
je jeho dokumentace~\cite{cemus2017automated}. Autoři \gls{ADDA}
využívají data mining pro získání metainformací o byznysových operacích,
datovém modelu systému a o byznysových pravidlech. Díky tomu mohou
automaticky vygenerovat seznam byznysových operací, potažmo implementovaných
use-cases, strukturu doménového modelu a formální popis byznysových pravidel,
který může sloužit pro verifikaci jejich správnosti.

\subsection{Výhody a nevýhody}

\gls{ADDA} poskytuje vývojářům způsob jakým výrazně snížit náklady na vývoj a údržbu
systému díky deduplikaci, která je dosažena extrakcí aspektů
do \textit{single focal point} a jejich automatickou distribucí do
příslušných komponent systému. Tento přístup však nese vysokou počáteční investici v
podobě vývoje specializovaných \gls{DSL} a dynamických aspect weaverů.
Ačkoliv autoři tohoto přístupu implementovali prototypy knihoven umožňující
požadovanou funkcionalitu, pro nasazení do reálného systému
nejsou tyto knihovny připraveny.

Přístup \gls{ADDA} splňuje požadavky identifikované v sekci~\ref{sec:implementation-requirements},
zejména využití speciálních \gls{DSL} pro popis aspektů a
jejich automatickou distribuci za běhu systému. Pro popis byznysových pravidel
využívá \gls{ADDA} nástroj \textit{Drools}, který je popsán v následující sekci.

\section{Stávaj\'{\i}c\'{\i} řešen\'{\i} reprezentace business pravidel}\label{sec:business-rule-dsl}

Tato kapitola se zaměřuje i na současné možnosti zachycení
byznysových pravidel ve specializovaných jazycích a vhodnost jejich použití
pro účel frameworku, který bude výstupem této práce.
Ačkoliv existuje relativně velké množství knihoven poskytujících
\gls{DSL} pro popis byznysových pravidel a umožňující automatickou
distribuci byznys pravidel, žádný z nich neposkytuje podporu velkého
množství programovacích jazyků, resp. platforem, ve kterých by mohl
být jazyk použit. Příkladem může být projekt \textit{business-ruless}
pro jazyk Python\footnote{https://pypi.org/project/business-rules/}, projekt FlexRule\footnote{http://www.flexrule.com/archives/business-rule-language/} pro platformy .NET a
JavaScript nebo \gls{BRMS} JRules\footnote{https://www.ibm.com/support/knowledgecenter/en/SSZJPZ\_11.3.0/com.ibm.swg.im.iis.conn.jrules.use.doc/topics/c\_jrules\_enginemode.html} od společnosti IBM pro platformu \gls{Java EE}.
Tato sekce se tedy zaměřuje zejména na framework Drools, který
používají autoři přístupu \gls{ADDA}, a také na moderní nástroj
JetBrains MPS, který umožňuje vytvářet vlastní \gls{DSL} a transformovat
ho do libovolných víceúčelových jazyků.

\subsection{Drools DSL}

Framework Drools\footnote{https://www.drools.org/} vyvijený společností JBoss\footnote{http://www.jboss.org/}
je open-source projekt realizující \textit{business rule management engine} (\gls{BRMS}),
tedy nástroj pro vývoj a správu byznysových pravidel. Framework umožňuje realizovat
tzv. \textit{produkční systémy}, tedy systémy tvořené sadou \textit{produkčních pravidel}
určujících chování programu. Tato pravidla obsahují popis situace a její řešení v případě,
že nastane. Tyto systémy tedy poskytují určitou formu umělé inteligence, která simuluje
rozhodování experta na danou doménu.

Produkční pravidlo se skládá z levé strany (\gls{LHS} z anglického \textit{left-hand side}),
a z pravé strany (\gls{RHS} z anglického \textit{right-hand side}),
\gls{LHS} popisuje situaci, při které má být pravidlo aplikováno. \gls{RHS} popisuje akci,
která má být vykonána.

Pro správnou funkci systému je nutno při vyhodnocování správně určit, která produkční pravidla
mají být aplikována. Pro tento účel využívá framework Drools algoritmus RETE~\cite{forgy1988rete},
vynalezený Charlesem Forgym v roce 1983, který je přímo navržený pro párování pravidel produkčních systémů.
Využívá stromové paměťové struktury, která minimalizuje výpočetní složitost na úkor paměťové složitosti. Framework
Drools navíc implementuje některá vylepšení algoritmu optimalizující jeho paměťovou složitost.

Součástí frameworku Drools je speciální doménově specifický jazyk vyvinutý přímo
pro modelování produkčních pravidel. Tento jazyk umožňuje popsat \gls{LHS} i \gls{RHS}
daného pravidla a k tomu využívá několik užitečných konstruktů. Pro popis situací i důsledků
využívá dialekt MVEL umožňující komfortní zápis logických výrazů. V rámci Drools \gls{DSL}
lze využívat lokální i globální proměnné s plnou typovou podporu pramenící z jazyka Java a také
podporu regulárních výrazů. Navíc je možno importovat i pomocné funkce, které lze
využít v podmínkách pravidla.

Ve zdrojovém kódu~\ref{lst:drools-example} je znázorněn příklad zápisu
byznysového pravidla v jazyce Drools DSL. Kromě názvu pravidla je v hlavičce
uvedeno, které dialekty jsou v pravidle využity. Dialekt \code{mvel} je popsán v přecchozím textu.
Dialekt \code{java} umožňuje pro \gls{RHS} využít přímo jazyk Java. Popsané produkční pravidlo
vypíše uživatelovo jméno a email, pokud má uživatel email vyplněný.

\lstinputlisting[
caption={Ukázka zápisu byznysového pravidla v jazyce Drools DSL},
label={lst:drools-example},
language=Drools,
%frame=single,
float,
floatplacement=t
]
{code/drools_example.drl}

Ačkoliv je jazyk Drools \gls{DSL} vymodelovaný přímo pro zápis pravidel doménovými experty,
produkčních pravidla se liší od byznysových pravidel zavedených v sekci~\ref{sec:business-rules},
Využít tak lze pouze \gls{LHS}. Zároveň jazyk Drools \gls{DSL} postrádá
nástroje pro kvalitní popis byznysového kontextu držícího byznysová pravidla,
zejména pak rozšiřování jiných kontextů a popis typu jednotlivých pravidel~\cite{cemus2017automated}.
V neposlední řadě nejsou ze strany frameworku Drools podporovány jiné platformy než
Java a .NET, což nevyhovuje požadavkům na platformovou nezávislost.

\subsection{JetBrains MPS}

Moderním nástrojem z dílny společnosti JetBrains\footnote{https://www.jetbrains.com/}
je tzv. \textit{MPS \textendash\xspace Meta Programming System}\footnote{https://www.jetbrains.com/mps/}, který si klade za úkol být univerzálním
nástrojem pro tvorbu doménově specifických jazyků. Staví na konceptu \textit{language-oriented
programming} (\gls{LOP})~\cite{ward1994language} zaměřujícího se na vývoj velmi specifického jazyka,
který je následně použit pro implementaci programu namísto obecného mnohoúčelového jazyka. Pro překlad
ze specifického jazyka do spustitelného kódu je použit automatický překladač. Příkladem jazyka, který využívá koncept \gls{LOP}
je \LaTeX\xspace, který byl využit pro sazbu této diplomové práce. Ten totiž pomocí maker jazyka \TeX\xspace
sestavuje abstraktnější jazyk, který umožňuje autorovi soustředit se hlavně na strukturu textu, aniž by
se musel příliš detailně zaobírat samotnou sazbou.

MPS umožňuje uživateli nadefinovat gramatiku speciálního \gls{DSL} a následně poskytuje
editor pro tento jazyk včetně automatického validátoru. MPS podporuje také transformování kódu napsaného
v nadefinovaném jazyce do jiných, nízkoúrovňovějších jazyků, zejména pak do jazyka Java.
Díky tomu lze nejen vytvářet libovolné \gls{DSL}, ale také rozšiřovat existující
jazyky \textendash\xspace například přidat do jazyka Java podporu pro jednoduchý vizuální
zápis matic, jak můžeme vidět na obrázku~\ref{fig:java-matrix}.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.7\linewidth]{figures/java-matrix.png}
    \caption{Rozšíření jazyka java o zápis matic pomocí JetBrains MPS}
    \label{fig:java-matrix}
\end{figure}

Výhoda tohoto přístupu je podobně jako u \gls{MDA} vysoká úroveň abstrakce, která
velmi dobře odděluje problém návrhu systému od implementačních problémů.
Navíc lze díky použití \gls{DSL} zapojit do vývoje doménové experty a snížit tak
zátěž na programátory, kteří se mohou více věnovat právě implementačním problémům.
\gls{DSL} typicky zvyšuje expresivitu kódu a díky tomu se zmenšuje jeho objem.
Nižší objem kódu vede ke snížení nákladů na jeho údržbu a vývoj~\cite{littman1987mental}\cite{soloway1986empirical}.
Významnou výhodou MPS, potažmo \gls{LOP}, je vysoká portabilita vyvinutého jazyka.
Pro migraci na jinou platformu stačí doprogramovat překladač jazyka, ale
samotný jazyk může zůstat zachovaný.

Nástroj MPS lze využít k popisu byznysových pravidel, resp. byznysových kontextů.
To by umožnilo snadné znovupoužití pravidel a jejich transformaci do neomezeného počtu jazyků pro
využití na mnoha platformách. Podobně jako u \gls{MDA} je však problém v dopředném
generování \textendash\xspace editor MPS totiž neumožňuje načíst víceúčelový jazyk zpět do \gls{DSL}.


\section{Síťové architektury}

Závěrem se tato kapitola věnuje přehledu síťových architektur, které mohou být využity pro
distribuci byznysových pravidel v systému stavějícímu na \gls{SOA}.

\subsection{Architektura klient-server}\label{sec:client-server}

Model klient-server popisuje vztah mezi komponentami systému, klienty a serverem.
Klient zašle požadavek serveru a ten mu vrátí odpověď~\cite{berson1992client}.
Schéma komunikace je znázorněno na obrázku ~\ref{fig:client-server}.
Tento model může být použit obecně i v rámci jednoho počítače,
nejčastěji je však využíván v síťové komunikaci mezi více počítači.
%V tomto případě klient sestaví síťové spojení k serveru a po získání odpovědi
%od serveru spojení zase uzavře.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.6\linewidth]{figures/client-server.pdf}
    \caption{Architektura klient-server}
    \label{fig:client-server}
\end{figure}

%Tato architektura je jednou ze základních stavebních kamenů
%internetových protokolů. Využívá ji zejména protokol
%\gls{TCP}~\cite{postel1981transmission}, který je hlavním
%komunikačním protokolem v síti Internet. Jako příklad si můžeme představit
%prohlížení internetových stránek. Uživatel zadá \gls{URL} adresu
%stránky, kterou chce navštívit, a internetový prohlížeč, potažmo uživatelův osobní počítač,
%v roli klienta odešle požadavek na server nacházející se na dané adrese.
%Server požadavek přijme, zpracuje, a odešle odpověď obsahující
%tělo webové stránky. Klient stránku přijme a zobrazí pro koncového
%uživatele.

Tento přístup má několik zásadních výhod, díky kterým se stal
široce využívaným. Díky svojí velmi obecné myšlence je nezávislý
na jakékoliv platformě.
%a jako klient i server mohou sloužit
%jak vysoce výkonné počítače, tak i osobní počítače nebo chytré telefony,
%z nichž každý může využívat odlišné operační systémy –
%stačí aby klient i server uměl komunikovat stejným protokolem.
Zároveň tato architektura přesouvá byznysovou logiku a
ukládání dat na server a díky tomu umožňuje
snadnější kontrolu nad systémem a jeho centrální administraci. S tím
je spojena i snažší škálovatelnost systému. V neposlední řadě
přináší model klient-server díky centralizaci i lepší zabezpečení,
kdy server může jasně definovat a vynucovat přístupová pravidla.

Hlavní nevýhodu této architektury je vytvoření jednoho centrálního bodu,
jehož výpadek ochromí funkci celého systému (v angličtině
\textit{single point of failure}) \textendash\xspace tímto bodem je server.
Pokud na serveru nastane chyba či výpadek, žádný z klientů není schopen využívat
jeho služeb.

%Pro sdílení byznysových pravidel se tato architektura jeví
%jako vhodná. Klient, který potřebuje byznysové pravidlo ke
%své funkci, by zažádal server o dané pravidlo a po jeho získání by
%se postaral o jeho spuštění. Tím by bylo dosaženo automatické
%distribuce a integrace byznysových pravidel. Vzhledem k tomu,
%že server je v této architetkuře centrální autoritou, usnadnila
%by se tak centrální správa byznysových pravidel.

\subsection{Architektura Peer-to-peer}\label{sec:p2p}

Opakem modelu klient-server je síťová architektura zvaná \textit{Peer-to-peer (\gls{P2P})}.
Jednotlivé počítače v síti spolu komunikují přímo, bez centrální autority.
Všechny počítače v síti jsou si vzájemně rovnocenné.~\cite{fox2001peer}
Na obrázku~\ref{fig:peer-to-peer} je tato architektura znázorněna.
Hlavním cílem \gls{P2P} sítí je distribuce dat nebo výpočetních operací.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.4\linewidth]{figures/peer-to-peer.pdf}
    \caption{Architektura peer-to-peer}
    \label{fig:peer-to-peer}
\end{figure}

%Jednotliví klienti mezi sebou zpravidla vytvářejí virtuální síť, tzv. \textit{overlay},
%která je postavená nad fyzickou sítí, přes kterou jsou reálně fyzicky zasílány zprávy mezi klienty.
%Typicky je tato virtuální síť podmnožinou existující fyzické sítě. Výhodou tohoto přístupu je,
%že klienti jsou abstrahováni od fyzického uspořádání počítačů a mohou spolu komunikovat napřímo,
%i když mezi nimi mohou reálně být v síti zapojeny jiné počítače.

Výhodou architektury \gls{P2P} rostoucí kapacita a výkon sítě s rostoucím počtem klientů,
narozdíl od modelu klient-server, kdy se klienti musí dělit o výkon serveru.
Navíc v takové síti neexistuje \textit{single point of failure} a tak se zvyšuje její robustnost.
Mezi nevýhody této architektury patří zvýšená bezpečnostní rizika způsobená tím,
že klienti jsou otevřeni komunikaci s jakýmkoliv jiným, potenciálně nebezpečným, klientem.
Další nevýhodou může být absence jakékoliv centrální správy sdílených dat.

Díky vysoké datové propustnosti a robustnosti se \gls{P2P} může jevit jako vhodný přístup pro
sdílení byznysových pravidel. Absence centrální správy by však mohla způsobit nekonzistentní stavy
systému při úpravě či přidání byznysového pravidla. To je způsobeno distribucí informací mezi více uzlů sítě.
Změna pravidla by se musela šířit postupně napříč systémem, přičemž některé uzly by stále využívaly starou
verzi pravidla. Nad samotným šířením nelze získat přímou kontrolu.

\subsection{Representational state transfer}\label{sec:rest}

Representational state transfer~\cite{fielding2000rest} (\gls{REST}) je architektura
webových služeb, která staví na protokolu \gls{HTTP}, a klade na systém
několik architektonických omezení, díky kterým může systém dosáhnout
lepšího výkonu, vyšší škálovatelnosti, jednoduchému používání díky jednotnému rozhraní
a lepší odolnosti vůči chybám.

\gls{REST} chápe data systému jako množinu zdrojů (z anglického \textit{resources}),
nad kterými jsou prováděny operace pomocí \gls{HTTP} požadavků. K odlišení operací
nad jedním zdrojem jsou využívána slovesa protokolu \gls{HTTP}, zejména pak \code{GET} pro čtení,
\code{POST} pro vytváření, \code{PUT} pro úpravu a \code{DELETE} pro mazání. Tím jsou zastřešeny
všechny \gls{CRUD} operace.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.9\linewidth]{figures/rest-statelessness.pdf}
    \caption{Znázornění architektury \gls{REST}}
    \label{fig:rest-statelessness}
\end{figure}

Principy architektury \gls{REST} jsou:

\begin{description}
    \item [Klient-server] Systém by měl využívat model klient-server. Díky tomu může jasně oddělit
    zodpovědnost za uživatelské rozhraní na klienta a zodpovědnost za ukládání dat na server. To zvyšuje
    škálovatelnost systému díky nižším nárokům na server.
    \item [Bezstavovost] Každý požadavek na server by měl obsahovat všechny informace potřebné k jeho vykonání.
    Kromě těla \gls{HTTP} požadavku se k tomuto účelu často využívají i hlavičky požadavku,
    například hlavička \code{Authorization} pro autentizaci uživatele kvůli přístupu k zabezpečeným zdrojům.
    Tím se zjednodušuje komplexita serveru, který plně přesouvá zodpovědnost za uchování stavu uživatelského rozhraní
    na klienta, jak je znázorněno na obrázku~\ref{fig:rest-statelessness}. Nutno poznamenat, že stav dat v systému
    je stále uchováván na serveru.
    \item [Kešování] Odpovědi serveru musí obsahovat explicitní informaci o tom, zda lze odpověď uložit do cache.
    Díky tomu je možné znovupoužívat data, která již server jednou vrátil, a jejich životnost má dlouhodobější charakter.
    Tím se zvyšuje výkon celého systému.
    \item [Vrstvený systém] Klient by neměl mít možnost rozeznat, zda komunikuje přímo se serverem, nebo s prostředníkem,
    např. s proxy serverem, load balancerem nebo cache.
    \item [Code-on-demand] Volitelným požadavkem na systém je tzv. \textit{code-on-demand}, který umožňuje serveru vracet
    spustitelný kód jako odpověď. Klient kód poté spustí na své straně. Typickým příkladem jsou klientské JavaScriptové aplikace spouštěné ve webových prohlížečích.
    \item [Jednotné rozhraní] Zdroje systému musejí mít unikátní identifikátor, např. \gls{URI}. Zdroje jsou při komunikaci reprezentovány libovolným formátem, který
    se může lišit od interní reprezentace zdroje v programu, např. \gls{JSON} či \gls{XML}. Reprezentace zdroje musí být
    dostatečná k tomu, aby šlo na zdroji provést úpravu či smazání. Zprávy mezi klientem a serverem musejí obsahovat veškerá potřebná metadata,
    aby druhá strana mohla zprávu plně zpracovat. K tomu se používají například \gls{HTTP} hlavičky \code{Content-type}
    či \code{Accept}, ve kterých je popsán typ reprezentace zdroje.
    Rozhraní by také mělo dodržovat koncept \textit{Hypermedia as the engine ot application state (\gls{HATEOAS})},
    který vyžaduje, aby server v odpovědích vracel metainformace o struktuře jeho \gls{API}.
    Klient je tak schopen dynamicky navigovat v rozhraní serveru aniž by bylo vyžadováno předem znát přesné adresy zdrojů.
    Princip \gls{HATEOAS} se však ve většině reálných \gls{API} zanedbává či implementuje pouze částečně.
\end{description}

Nevýhodou architektury \gls{REST} je náročná implementace transakcí, které zahrnují více
zdrojů najednou. Protokol \gls{HTTP} nepodporuje uzavření více požadavků do jedné atomické
transakce. To může být problém v \gls{SOA} zejména pokud je vyžadována kooperace více služeb
najednou při vykonávání byznysové operace. Existují však koncepty, které využívají model
Try-Cancel/Confirm~\cite{pardon2011towards}, umožňující zajistit atomické transakce nad
\gls{REST} architekturou. Další nevýhodou je relativně náročná implementace samotné architektury
kvůli neexistujícímu obecnému middleware, který by poskytoval

\subsection{Remote procedure call}\label{sec:rpc}

Remote procedure call (\gls{RPC}) je podstatně starší architekturou než \gls{REST}.
Tento termín byl použit již v roce 1981 Brucem Nelsonem~\cite{nelson1981remote}.
Architektura staví na modelu klient-server a umožňuje jednomu procesu (klientovi)
zavolat proceduru na druhém, vzdáleném procesu (serveru).
Klient zašle serveru zprávu vyžadující zavolání specifické procedury. Server
proceduru provede a po jejím dokončení zašle klientovi odpověď s návratovou hodnotou.
Klient poté může pokračovat ve své práci.

\gls{RPC} zapouzdřuje síťovou komunikaci a v programu samotném
je vzdálená procedura volána stejným způsobem jako lokální procedury. Základním
prvkem architektury na klientovi i na serveru je tzv. \textit{stub}. Tato komponenta
umožňuje volat, resp. obsloužit, vzdálenou proceduru lokálně a zapozdřuje veškerou
síťovou komunikaci a serializaci či deserializaci argumentů, resp. návratových hodnot.
Schéma komunikace je znázorněno na obrázku~\ref{fig:rpc}.

\begin{figure}[t]
    \centering
    \includegraphics[keepaspectratio=true, width=0.7\linewidth]{figures/rpc.pdf}
    \caption{Schéma komunikace \gls{RPC}}
    \label{fig:rpc}
\end{figure}

%Představitelem architektury \gls{RPC} je například technologie \gls{CORBA},
%která již byla popsána v sekci~\ref{sec:corba}, nebo technologie Remote
%Method Invocation (\gls{RMI}) v jazyce Java. Modernějším pojetím je technologie gRPC~\cite{grpcio}
%od společnosti Google\footnote{https://www.google.com/},
%která je v dnešní době hromadně využívána úspěšnými technologickými společnostmi.

Nevýhodou abstrakce lokálních a vzdálených volání jsou
negativní vlastnosti síťové komunikace, její zvýšená latence
a nižší robustnost. Pokud programátor nemá možnost zjistit, zda volá
lokální či vzdálenou proceduru, výsledný kód může být těžké optimalizovat
a správně ošetřit výjimky, které mohou při jeho běhu nastat.
Pro \gls{RPC} však není potřeba implementovat komplexní middleware obstarávající
síťovou komunikaci, serializaci a zpracování chyb. Middleware je zpravidla dodáván v
podobě knihoven dané technologie. \gls{RPC} stejně jako \gls{REST}
ani \gls{RPC} nedefinuje, jakým způsobem by měly být obslouženy transakce.

\section{Shrnut\'{\i}}

Tato kapitola popisuje rešerši \textit{modelem řízené architektury},
\textit{generativního programování}, \textit{BPEL},
jej\'{\i}ch v\'yhody a nev\'yhody. Shrnuje existující síťové architektury,
které mohou být využity pro komunikaci služeb v architektuře \gls{SOA}
a zvažuje vhodnost jejich použití pro účely této práce.
Kapitola dále shrnuje jsme paradigma \textit{aspektově orientovaného programován\'{\i}} a
věnuje se inovativnímu přístupu k návrhu softwarov\'ych systémů \textit{ADDA}.
Nakonec se kapitola věnuje rešerši stávaj\'{\i}c\'{\i}ch řešen\'{\i} reprezentace byznys pravidel
včetně komplexn\'{\i}ho frameworku \textit{Drools} a hodnotí jejich vhodnost pro použití v této práci.
