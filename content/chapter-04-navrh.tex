%!TEX ROOT=../diploma-thesis.tex

\chapter{Návrh}\label{ch:navrh}

V této kapitole je diskutován návrh frameworku pro centrální správu
a automatickou distribuci business pravidel vyhovující požadavkům identifikovaným
v sekci~\ref{sec:implementation-requirements}. Tento návrh staví na znalostech získaných
v předchozí kapitole~\ref{ch:reserse}, zejména na paradigmatu \gls{AOP} a přístupu \gls{ADDA}.

\section{Formalizace architektury orientované na služby}

Pro formalizaci problému byznysových pravidel v \gls{SOA} do termínů \gls{AOP} musíme
identifikovat \textit{join-points}, určit podobu \textit{advices}, popsat způsob jakým budou
zachyceny \textit{pointcuts} a nakonec navrhnout proces \textit{weavingu} pravidel.

\subsection{Join-points}

Při identifikování join-points budeme vycházet ze životního cyklu služby, který je znázorněn
na obrázku~\ref{fig:join-points}. První fází v životě instance služby je její inicializace,
konkrétně načtení aplikačního kontextu. V tomto bodě je potřeba získat veškerá pravidla, která
bude služba potřebovat ke své funkci.
Po inicializaci vstupuje služba do fáze, ve které může přijímat požadavky
na vykonání byznysových operací. Při přijmutí požadavku je nejprve nutno určit
byznysový kontext a poté vyhodnotit veškeré \textit{preconditions}. Pokud jsou všechny předpoklady
pro spuštění operace splněny, může být vykonána. Po dokončení operace je nutno aplikovat relevantní
post-conditions.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=0.6\linewidth]{figures/join-points.pdf}
    \caption{Diagram životn\'{\i}ho cyklu služby a identifikovan\'ych join-pointů}
    \label{fig:join-points}
\end{figure}

Identifikované join-points tedy jsou:

\benum[label=\circledarabic]
\item\label{itm:initialization} Inicializace instance služby
\item\label{itm:before} Volání byznysové operace
\item\label{itm:after} Dokončení byznysové operace
\eenum

\subsection{Pointcuts}

V join-pointu~\ref{itm:initialization} by služba měla načíst všechna byznysová pravidla, která
bude potřebovat ke své činnosti, a nejsou pro ni lokálně dostupná. Služba tedy musí zjistit,
která pravidla je potřeba získat, a následně si je vyžádat od ostatních služeb.
V join-pointech~\ref{itm:before}~a~\ref{itm:after} musejí být aplikována byznysová pravidla každého
kontextu vztahujícího se k dané operaci.

\lstinputlisting[
caption={Ukázka zápisu validačních pravidel pomocí anotací v jazyku Java},
label={lst:jsr303},
language=Java,
%frame=single,
%float,
%floatplacement=t
]
{code/jsr303.java}

Pro zápis selektoru poincutu byznysového pravidla se lze inspirovat standardem \gls{JSR}
303~\cite{bernard2009jsr}, který umožňuje validovat data byznysových objektů vstupujících do
byznysových operací pomocí anotací atributů těchto objektů. Příklad validačních anotací je znázorněn
ve zdrojovém kódu~\ref{lst:jsr303}, kde je pomocí anotace \code{$@$NotNull} zajištěno, že fakturační
adresa bude mít vyplněna všechna pole (v kontextu našeho frameworku se jedná o paralelu preconditions).
Podobným způsobem by každá byznysová operace mohla pomocí metainstrukcí specifikovat, která byznysová
pravidla bude využívat. Toto řešení však neposkytuje možnost dynamicky při běhu programu změnit sadu
byzynsových pravidel. Tento problém lze řešit zavedením konceptu byznysového kontextu, který
zapouzdřuje byznysová pravidla, a byznysová operace se na něj může explicitně odkázat. Obsah byznysového
kontextu by přitom mohl být dynamicky změněn za běhu programu.

Sdílení pravidel mezi byznysovými kontexty, potažmo byznysovými operacemi a mezi jednotlivými službami,
by lze realizovat pomocí dědičnosti kontextů. Každý kontext, který by potřeboval validovat fakturační
adresu, by tak mohl pouze dědit od kontextu vytváření faktury. Na obrázku~\ref{fig:context-extension}
je dědičnost kontextů znázorněna. Kontext vytváření objednávky dědí od kontextu vytváření faktury
a znovupoužívá jeho byznysová pravidla. Byznysové operace se odkazují na byznysové kontexty, které mají
být při jejich vykonávání použity. Před spuštěním a po dokončení operace vytváření
objednávky jsou aplikována pravidla obou kontextů, zatímco při vytváření faktury jsou zohledněna
pouze pravidla jednoho kontextu.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=1\linewidth]{figures/context-extension.pdf}
    \caption{Diagram znázorňující dědičnost kontextů ve vztahu k join-pointům a pointcuts}
    \label{fig:context-extension}
\end{figure}

\subsection{Advices}

V případě join-pointu~\ref{itm:initialization} se za advice dá považovat reprezentace byznysového
kontextu přenášeného mezi službami. Naopak v join-pointech~\ref{itm:before}~a~\ref{itm:after}
je přidanou funkcionalitou vyhodnocování preconditions nad aplikačním kontextem, resp. aplikování
post-conditions na návratovou hodnotu operace.

\subsection{Weaving}

Weaving v případě join-pointu~\ref{itm:initialization} bude provádět komponenta frameworku, která
analyzuje lokálně dostupná pravidla služby, vyhodnotí, která pravidla je potřeba stáhnout,
a vyžádá tato pravidla od příslušných služeb.
V případě join-pointů~\ref{itm:before}~a~\ref{itm:after} je k weavingu potřeba využít speciální aspect
weaver. Ten zachytí volání byznysové operace a získá informace o aktuálním stavu aplikačního kontextu.
Následně zjistí, který byznysový kontext má být aplikován, shromaždí všechny preconditions
a každou z nich vyhodnotí. Pokud některá precondition není splněna, byznysová operace je zastavena
a je vyhozena výjimka, kterou služba zpracuje. V opačném případě je kontrola vrácena zpět
službě, která vykoná byznysovou operaci. Po dokončení operace aspect weaver zachytí výstup byznysové
operace a aplikuje post-conditions daného byznysového kontextu. Proces weavingu je zachycen na
obrázku~\ref{fig:business-rules-weaver}.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=0.8\linewidth]{figures/business-rules-weaver.pdf}
    \caption{Diagram aktivit weaverů byznysov\'ych pravidel}
    \label{fig:business-rules-weaver}
\end{figure} % TODO: popsat

\section{Dědičnost byznysových kontextů}\label{sec:context-inheritance}

V předchozím textu byl představen koncept dědičnosti byznysových kontextů.
Každý kontext díky němu může rozšiřovat libovolné množství jiných kontextů, a sdílet jejich
byznysová pravidla. Byznysové operace pak mohou samy určit, který byznysový kontext se k ním váže.
Tento kontext však přináší několik problémů, které vyřešíme v následujícím textu.

Mapování byznysových kontextů a byznysových operací jedna ku jedné by mohlo vést k situaci,
kdy chceme využít pouze nějaká byznysová pravidla jiného kontextu, ale ne všecha.
Příkladem může být proces vytváření objednávky a proces registrace uživatele.
Při vytváření objednávky chceme zaslat uživateli potvrzující mail, a proto potřebujeme, aby
měl vyplněnou e-mailovou adresu. Zároveň chceme, aby byl uživatel při vytváření objednávky přihlášený.
Při registraci uživatele bychom mohli rozšířit kontext vytváření objednávky, ovšem nechceme využít pravidlo
vyžadující přihlášení uživatele. Tuto situaci lze vyřešit rozvolněním vztahu mezi kontexty a operacemi
a umožněním využití tzv. \textit{abstraktních kontextů} \textendash\xspace tedy takových kontextů, které
přímo nevyužívá žádná byznysová operace. Situace je znázorněna na obrázku~\ref{fig:abstract-context}.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=1\linewidth]{figures/abstract-context.pdf}
    \caption{Diagram konceptu abstraktního byznysového kontextu}
    \label{fig:abstract-context}
\end{figure}

Dalším problémem je kruhová závislost kontextů, která nastává, když kontext A dědí od kontextu B,
a ten opět dědí od kontextu A. Pokud tato situace nastane, nelze ji z hlediska frameworku vyřešit.
Je tedy nutné, aby byznysové kontexty systému využívajícího navrhovaný framework neobsahovaly žádný cyklus.
K zajištění této skutečnosti by mohl sloužit validátor vestavěný do nástroje pro správu byznysových kontextů.

Kvůli vícenásobné dědičnosti může nastat problém, kdy jeden kontext zdědí více stejných pravidel z
různých zdrojů. Představme si, že kontext D dědí od kontextů B a C, přičemž kontexty B a C dědí
od kontextu A. Kontext D pak zdědí pravidla kontextu A dvakrát. Tomu lze předejít tak, že
každé pravidlo bude mít unikátní identifikátor v rámci celého systému a při dědění budou zohledněna
pouze unikátní pravidla. Zajištění unikátního identifikátoru můžeme vynutit díky nástroji pro centrální
administraci byznysových pravidel, která je součástí navrhovaného frameworku.

Posledním problémem je zdědění takové množiny preconditions, která nebude nikdy
splnitelná. Například pokud jedna precondition vyžaduje příhlášení uživatele a druhá precondition požaduje
opak. Takovéto stavy by měl primárně hlídat administrátor či architekt systému, nicméně můžeme
jeho práci usnadnit díky nástroji pro centrální administraci kontextů.

\section{Logické výrazy byznysových pravidel}

Sekce~\ref{sec:business-rules} uvádí, že pravidla obsahují logické podmínky, které je
potřeba vyhodnocovat. V případě preconditions je to ověření podmínky, která musí být platná před spuštěním
byznysové operace. V případě post-condition není logická podmínku potřeba vždy, ale může nastat moment,
kdy je filtrování návratové hodnotry potřeba pouze pokud je splněna nějaká podmínka \textendash\xspace
například pokud uživatel není administrátorem.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=1\linewidth]{figures/expression.pdf}
    \caption{Diagram tříd popisující použití vzoru Intepreter pro vyhodnocování logických výrazů}
    \label{fig:expression}
\end{figure}

Vyhodnocování logických výrazů byznysových pravidel bude prováděno frameworkem
při weavingu byznysových kontextů. K tomuto účelu je vhodný návrhový vzor
\textit{Interpreter}~\cite{fowler2002patterns} umožňující interpretaci
jazyka, kdy každý jeho výraz (z anglického \textit{expression}) je reprezentován
samostatným objektem, který přebírá zodpovědnost za správnou interpretaci daného výrazu.
Logické výrazy tvoří orientovaný acyklický graf (\gls{DAG}), tzv. \textit{derivační strom},
a rozdělují se na tzv. \textit{terminály} a \textit{neterminály}~\cite{melichar2003jazyky}.
Terminál znamená, že z daného výrazu již nevychází žádná hrana do jiného výrazu. Neterminál je opak terminálu.
Na obrázku~\ref{fig:expression} můžeme vidět použití vzoru interpreter pro tento účel.
Strom interpretovaných výrazů využívá návrhový vzor \textit{Composite}~\cite{fowler2002patterns}.

Framework bude disponovat základní sadou logických výrazů, které budou
sloužit pro zápis byznysových pravidel. Těmi budou základní logické operace jako je
\code{and}, \code{or}, \code{equals} a \code{negate}. Výraz, který získá hodnotu proměnné
či konstanty z kontextu. Pokud bude v kontextu uložen objekt, je potřeba přistupovat i k jeho
veřejným atributům, což bude zajišťovat další speciální výraz. K ověření přítomnosti hodnoty v proměnné
bude sloužit výraz \code{IsNotNull}. Výraz \code{IsNotBlank} ověří, zda je v proměnné řetězec
nenulové délky. Pro vložení konstantní hodnoty přímo do byznysového pravidla bude sloužit terminál \code{Constant}.
Pro zvýšený komfort budou přidány i výrazi realizující základní matematické operace sčítání, odečítání,
násobení a dělení. Pro volání uživatelských funkcí definovaných v operačním kontextu bude sloužit speciální výraz
\code{FunctionCall}. V jeho případě je nutno zohlednit skutečnost, že funkce může přijímat libovolný počet argumentů.
Protože volaná funkce může potřebovat přistupovat k operačnímu kontextu, musejí být argumenty také interpretovány.
Bohužel nelze u uživatelem definovaných funkcí ověřit, že bude při jejich volání odpovídat počet a typ argumentů.
Přehled všech výrazů, které bude framework podporovat, je v tabulce~\ref{tbl:expressions},

\goal{Typované výrazy}
Konstanty, proměnné a návratové hodnoty využívané ve výrazech mohou nabývat
různých hodnot rozdílného typu. Pro umožnění implementace frameworku na více platformách je
k logickým výrazum potřeba explicitně uložit informace o typu jejich argumentů a jejich návratové hodnoty.
Díky tomu bude navíc možné framework rozšířit o typovou kontrolu, což přinese menší náchylnost
k sémantickým chybám v zápisu pravidla. Výraz byznysového pravidla může nabývat logických hodnot,
může vracet číslo, textový řetězec a také objekt. Je potřeba počítat také s tím, že výraz nevrací žádnou
hodnotu.

\begin{itemize}
    \item \code{BOOL} je logický typ, který nabývá hodnoty \code{true} a \code{false}.
    \item \code{NUMBER} je reálné číslo zapsáno ve tvaru s desetinnou tečkou a neomezeným počtem číslic.
    \item \code{OBJECT} je objekt libovolného typu.
    \item \code{STRING} je textový řetězec.
    \item \code{VOID} je pseudotyp značící, že výraz nemá návratovou hodnotu.
\end{itemize}

\goal{Atributy pravidel}
Kromě argumentů neterminálů je v některých případech potřeba k výrazu uložit i dodatečné informace \textendash\xspace
\textit{atributy}. Jedním z atributů je typ návratové hotnoty výrazu, pokud není přímo implikována.
V případě výrazu \code{Constant} je potřeba uložit hodnotu a typ konstanty. Reference na proměnnou
musí obsahovat její název a typ, reference na pole objektu navíc musí obsahovat název odkazovaného pole.
Volání funkce musí obsahovat její název a návratový typ.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=1\linewidth]{figures/simple-rule.pdf}
    \caption{Syntaktický strom jednoduchého validačního pravidla}
    \label{fig:simple-rule}
\end{figure}

\goal{Příklad AST pravidla}
Na obrázku~\ref{fig:simple-rule} je znázorněn vidět syntaktický strom, který zachycuje jednoduché
validační pravidlo validující fakturační adresu. Jedná se o ekvivalent validačních pravidel
zachycených ve zdrojovém kódu~\ref{lst:jsr303} pomocí anotací standardu \gls{JSR} 303.
Pravidlo je tvořeno čtyřmi teminály, které se odkazují na proměnné operačního kontextu.
Každá z těchto proměnných je argumentem validačního výrazu \code{IsNotBlank}. Jednotlivé validace
jsou spojeny pomocí binárního výrazu \code{LogicalAnd} odpovídací logické konjunkci.
Pro přehlednost nejsou v diagramu zaneseny návratové typy výrazů.

\section{Filtrování návratových hodnot byznysové operace}

Při aplikování post-conditions je filtrována návratová hodnota byznysové operace. Tou může být proměnná
obsahující číslo, text, objekt, či jejich kolekce. Filtrování jednoduchých hodnot nemá pro byznysová pravidla reálný přínos.
V případě objektu lze filtrovat jeho atributy, například skrýt e-mailovou adresu uživatele.
V případě kolekce lze filtrovat jejich prvky, například skrýt objednávky, které uživateli nepatří.
Pokud se v kolekci nachází objekty, lze požadovat, aby byly zakryty atributy jednotlivých objektů,
například filtrování e-mailových adres v kolekci více uživatelů. Itentifikovanými typy post-conditions tedy jsou:

\begin{itemize}
    \item \code{FILTER\_OBJECT\_FIELD} filtruje atribut objektu, který je výstupem operace.
    \item \code{FILTER\_LIST\_OF\_OBJECTS} filtruje objekty v kolekci, která je výstupem operace.
    \item \code{FILTER\_LIST\_OF\_OBJECTS\_FIELDS} filtruje atributy objektů v kolekci, která je výstupem operace.
\end{itemize}

\section{Metamodel byznysového kontextu}\label{sec:metamodel}

Z předchozího textu vyplývá podoba metamodelu byznysových pravidel, resp. byznysových kontextů.
Kromě samotných logických výrazů musí pravidlo nést informace o tom, zda
se jedná o precondition nebo post-condition, a také jeho identifikátor.
Post-condition navíc potřebuje uložit informaci o jejím typu a názvu. Pravidla jsou uskupována
do byznysových kontextů, z nichž každý má svůj unikátní identifikátor skládající se z prefixu
a samotného jména a seznam rozšířených kontextů. Diagram tříd navrženého kontextu je znázorněn
na obrázku~\ref{fig:business-context-metamodel}.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=\linewidth]{figures/business-context-metamodel.pdf}
    \caption{Diagram tř\'{\i}d metamodelu byznysového kontextu}
    \label{fig:business-context-metamodel}
\end{figure}

\section{Popis byznysových kontextů pomocí \gls{DSL}}

Př\'{\i}stup \gls{ADDA} doporučuje popsat byznysová pravidla pomoc\'{\i}
vlastn\'{\i}ho, na m\'{\i}ru šitého, doménově specifického jazyka~\cite{cemus2015automated}.
Pro účely frameworku bude popsán pomocí \gls{DSL} celý byznysový kontext.
Jak bylo popsáno v sekci~\ref{sec:business-rule-dsl}, vlastnosti nástrojů Drools a JetBrains MPS,
nejsou optimální pro dosažení vytyčených cílů. Pro účely frameworku je tedy nutné specifikovat vlastnosti,
které by \gls{DSL} mělo nést. Konkrétní podoba DSL bude přenechána na implementaci frameworku.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=1\linewidth]{figures/expression-visitor.pdf}
    \caption{Diagram tříd popisující využití vzoru Visitor pro zápis logických výrazů v \gls{DSL}}
    \label{fig:expression-visitor}
\end{figure}

Pro uložení kontextu z metamodelu do \gls{DSL}, aby ho mohl vývojář či administrátor
systému upravovat, je vzhledem k reprezentaci logických výrazů vhodný návrhový vzor
\textit{Visitor}~\cite{fowler2002patterns}. Ten umožní převádět libovolně složité logické
výrazy pomocí metody \textit{double-dispatch}. Jeho volbou je zároveň zajištěna rozšiřitelnost
frameworku pro libovolné \gls{DSL} \textendash\xspace bude stačit implementovat konkrétní
visitor pro zvolený jazyk, aniž by bylo nutno zasahovat přímo do implementace frameworku.
Princip použití vzoru Visitor je znázorněn na obrázku~\ref{fig:expression-visitor}.

\section{Organizace byznysových kontextů}

Každá služba bude mít lokálně uložen popis byznysových kontextů, které se sémanticky vztahují
k její doméně. Pro snažší přidělení byznysových kontextů ke službám bude v identifikátoru kontextu sloužit
tzv. \textit{prefix}. Kontexty se stejným prefixem pak budou spravovány výhradně jednou službou. Například kontexty
služby spravující objednávky budou označeny prefixem \code{order}, zatímco kontexty služby zajišťující fakturaci budou
označeny prefixem \code{billing}. Může nastat i situace, kdy jedna služba bude spravovat více prefixů.

\subsection{Registr byznysových kontextů}

Cílem frameworku je soustředit byznysové kontexty na jedno místo, ze kterého budou
automaticky distribuovány. Pro tento účel bude využit registr byzynsových pravidel
(\code{BusinessContextRegistry}), který bude mít za úkol kontexty načítat z \gls{DSL} do metamodelu,
stahovat lokálně nedostupné kontexty z ostatních služeb a načtené kontexty uchovávat pro použití při weavingu.
Každá služba pak bude disponovat svým registrem. Při inicializaci kontextů spolu budou registry komunikovat
a vyměňovat si sdílené kontexty.

\subsection{Uložení kontextů}

Byznysové kontexty popsané pomocí \gls{DSL} mohou být v příslušné službě uloženy v souborech na disku či v
databázi. Navrhovaný framework by na způsobu uložení neměl být závislý a o potřebné kroky
pro načtení či případně uložení kontextu se postará konkrétní implementace. Pro tento účel
je tedy vhodné, aby registr pracoval s nekonkrétními rozhraními, na jejichž implementaci
nebude nijak záviset.

\section{Inicializace byznysových kontextů}
%Při inicializaci služby je potřeba načíst všechny byznysové kontexty, které bude služba
%pro svůj běh potřebovat. Mohli bychom argumentovat, že načítat příslušný kontext by šlo
%až ve chvíli, kdy je opravdu zavolána byznysová operace. Kontext bychom pak mohli uložit
%do paměti, aby se nemusel načítat při dalším spuštění operace. Toto řešení by rozprostřelo
%latenci při inicializaci služby mezi jednotlivá první spuštění každé byznysové operace.
%Zároveň by se však zvýšila komplexita frameworku. V rámci principů \gls{KISS}~\cite{kiss}
%a \gls{YAGNI}~\cite{beck2000extreme} využijeme první zmíněné řešení. Nicméně, pokud by druhé
%řešení v budoucnu přinášelo další benefity, můžeme ho do frameworku snadno přidat.

\begin{figure}
    \centering
    \includegraphics[keepaspectratio=true, width=\linewidth]{figures/business-context-loading.pdf}
    \caption{Diagram procesu inicializace byznysov\'ych kontextů}
    \label{fig:business-context-loading}
\end{figure}

Během inicializiace byzynsových kontextů je potřeba nejprve načíst lokálně dostupné kontexty popsané pomocí \gls{DSL}.
Po převedení z \gls{DSL} do metamodelu je potřeba shromáždit seznam rozšířených kontextů a zjistit, které
rozšířené kontexty nejsou lokálně dostupné. Následně je potřeba vyžádat si vzdálené kontexty od příslušných služeb
a převést obdržené kontexty z formátu pro síťový přenos do formátu, ve kterém budou kontexty uloženy v paměti.
Nakonec je potřeba, aby do všech kontextů, které využívají dědičnosti, byly začleněny byznysová pravidla
rozšířených kontextů. Celou inicializaci může zastřešovat komponenta \code{BusinessContextRegistry}, která
má znalost o všech subsystémech, které jsou k tomuto procesu potřeba. Tato komponenta implementuje
návrhový vzor \textit{Facade}~\cite{fowler2002patterns}. Na obrázku~\ref{fig:business-context-loading} je znázorněn
navržený proces inicializace.

\section{Centráln\'{\i} správa byznysových kontextů}

Vzhledem k nutnosti centralizovat správu byznysových kontextů se
architektura \gls{P2P} představená v sekci~\ref{sec:p2p} nehodí.
Při úpravě kotextů by totiž v systému mohly existovat najednou staré i nové verze
byznysových pravidel, což je pro správnou funkci systému nepřijatelné.
Framework tedy využije architektury klient-server s více servery.
Byznysové kontexty budou podle prefixu přideleny službám, které budou
spravovat jejich aktuální a jediný stav a poskytovat je jiným službám.

\subsection{Uložen\'{\i} rozšířeného pravidla}\label{sec:saving-context}

\goal{Diskutovat chaining vs. direct update}
Při ukládání byznysového kontextu, od kterého dědí jiné kontexty, je potřeba zajistit,
že bude změna korektně propagována. Při změně rozšířeného pravidla budou všechny služby,
které ho využívají informovány pomocí nástroje pro centrální správu byzynsových pravidel.
Ten má informaci o všech závislostech v systému a zároveň zná i adresu všech služeb.
Nástroj by tak při ukládání upraveného pravidla zmapuje, které kontexty je potřeba aktualizovat,
a následně o to požádá služby spravující tyto kontexty. Nevýhodou tohoto přístupu je zvýšená komunikačmní
zátěž kvůli většímu objemu přenesených informací. Je nutno zvážit, zda je tato zátěž vůči absolutnímu objemu
přenášených dat v systému využívajícímu \gls{SOA} zanedbatelná. Při implementaci by bylo vhodné
vybrat vhodný přenosový formát, který minimalizuje dopad veškeré síťové komunikace týkající se
distribuce byznysových pravidel.

\subsection{Proces úpravy kontextu}

Proces úpravy byznysového kontextu pomocí nástroje pro centrální administraci nejprve načte všechny
byznysové kontexty všech služeb v systému. Následně zobrazí administrátorovi formulář pro úpravu pravidla.
Pravidlo je pro účely formuláře převedeno z metamodelu do \gls{DSL}. Po odeslání formuláře bude pravidlo
převedeno zpět do metamodelu. Nástroj pro administraci poté analyzuje, na které služby bude
mít změna pravidla dopad. Následně je s těmito službami zahájena transakce, při které v nich
nesmí probíhat žádná byznysová operace. Když všechny ovlivněné služby zahájí transakci, je možno
jim rozeslat novou podobu pravidla. Pokud vše proběhne v pořádku, je možno transakci dokončit
a služby otevřít byznysovým transakcím. Pokud naopak některý z kroků transakce selže, je nutno
informovat všechny zúčastněné služby o zrušení transakce a změnu inkriminovaného pravidla zrušit.
Na obrázku~\ref{fig:business-context-management} je celý proces znázorněn. Proces pro uložení
nového kontextu je analogický.

\section{Architektura frameworku}\label{sec:architecture}

V této sekci je popsána obecná architektura navrženého frameworku v rámci služby využívající
klasickou třívrstvou architekturu~\cite{fowler2002patterns}, která se skládá z prezentační,
aplikační a datové vrstvy. Každá z těchto vrstev může framework využívat
\textendash\xspace prezentační vrstva při validování vstupních polí formuláře, aplikační vrstva při
aplikaci byzynsových pravidel v byznysových operacích a datová vrstva při aplikaci post-conditions pro
filtrování dat při jejich získávání z databáze.

Základem frameworku je komponenta \code{BusinessContextRegistry}, tedy registr
byznysových kontextů, který je zodpovědný za inicializaci a uchovávání byznysových kontextů.
Načítání kontextů lze rozdělit na lokální a vzdálené. Při načítání lokálně dostupných kontextů
je potřeba získat \gls{DSL} kontextu ze souboru či databáze a převést ho do metamodelu.
K tomu bude využito rozhraní \code{LocalBusinessContextLoader}. Implementace rozhraní může být libovolná
a záviset na použitém \gls{DSL} či místu uložení pravidel. Naopak při načítání vzdálených
kontextů je potřeba vyžádat kontexty od vzdálené služby. O to se postará třída \code{RemoteBusinessContextLoader},
která požadované kontexty zorganizuje podle prefixu a poté pomocí rozhraní \code{RemoteLoaderClient} načte
pravidla od jednotlivých služeb. Implementace rozhraní \code{RemoteLoaderClient} bude záviset na použité
technologii a zajistí síťovou komunikaci a převod do a z formátu pro síťový přenos.
Aby mohl framework poskytovat lokální byznysové kontexty dané služby ke stažení, musí zastřešit
i serverovou funkcionalitu. K tomu slouží rozhraní \code{BusinessContextServer}. To bude využívat
\code{BusinessContextRegistry}, ze kterého načte byznysové kontexty, které si vyžádá \code{RemoteLoaderClient}.
Implementace serveru bude opět závislá na konkrétní technologii.
Nakonec bude framework obsahovat sadu aspect weaverů, které umožní weaving byznysových pravidel do
jednotlivých vrstev systému. Pro účely této práce bude framework poskytovat weavery pro využití v
aplikační vrstvě pro weaving preconditions a post-conditions do byznysových operací.
Architektura je zachycena na obrázku~\ref{fig:business-context-registry}.

\subsection{Service discovery}

Aby framework mohl distribuovat byznysové kontexty mezi službami, musí služba vyžadující kontext
znát adresu služby, od které ho vyžaduje. Adresy služeb mohou podléhat různým konfiguracím,
které se mohou lišit systém od systému. Framework proto nesmí být závislý na způsobu,
jakým se adresování služeb provádí. Nejlepším řešením je přenechat na uživateli frameworku, aby sám
získal a předal adresy služeb ve chvíli, kdy je framework potřebuje \textendash\xspace tedy
ve chvíli, kdy je potřeba načíst lokálně nedostupné kontexty.

\section{Shrnutí}

V této kapitole byl popsán návrh frameworku pro centrální správu a automatickou distribuci
byznysových pravidel v \gls{SOA} na základě přístupu \gls{ADDA}. Nejprve byla formalizována
doména byznysových pravidel v \gls{SOA} do názvosloví \gls{AOP}. Dále byla diskutována podobu byznysových pravidel,
jejich logických výrazů a jakým způsobem je lze zachytit v metamodelu a v \gls{DSL}.
Kapitola dále popisuje organizaci kontextů a procesy, kterými budou distribuovány a spravovány.
Nakonec byla shrnuta architektura frameworku.
