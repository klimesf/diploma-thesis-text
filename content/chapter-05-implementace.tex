%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}

%!TEX ROOT=../diploma-thesis.tex

\chapter{Implementace prototypů knihoven}\label{ch:implementace}

\goal{Uveden\'{\i} kapitoly a nast\'{\i}něn\'{\i} obsahu}
Součást\'{\i} zadán\'{\i} této práce je implementace prototypů
knihoven pro framework navržen\'y v kapitole~\ref{ch:navrh}
pro tři rozd\'{\i}lné platformy, z nichž jedna mus\'{\i} b\'yt \textit{Java}.
V této kapitole si pop\'{\i}šeme, jaké plaformy jsme vybraly, a jak\'ym
způsobem byly prototypy knihoven implementovány. Součást\'{\i}
kapitoly je i stručná rešerše technologi\'{\i}, které byly použity
pro dosažen\'{\i} vytyčen\'ych c\'{\i}lů.

\goal{Nástin formátu kapitoly}
Jelikož vycházej\'{\i} implementace knihoven pro všechny platformy
ze stejného návrhu představeného v předchozí kapitole~\ref{ch:navrh},
pop\'{\i}šeme si kompletn\'{\i} implementaci pro jazyk
Java a ostatn\'{\i} implementace shrneme komparativn\'{\i} metodou.

\goal{Technické implementačn\'{\i} problémy}
Pro splněn\'{\i} c\'{\i}lů bylo potřeba vyřešit také několik technick\'ych otázek,
jako je přenos byznys kontextů mezi jednotliv\'ymi službami, v\'yběr formátu
pro zápis byznys kontextu, podpora aspektově orientovaného programován\'{\i}
v daném programovac\'{\i}m jazyce a využit\'{\i} principu \textit{runtime weavingu}
a integrace knihoven do služeb, které je budou využ\'{\i}vat.

\section{V\'yběr použit\'ych platforem}

\goal{Jaké jsme vybrali dalš\'{\i} platformy a proč}
Mimo jazyk Java, kter\'y byl určen zadán\'{\i}m, byla pro
implementaci vybrána platforma jazyka \textit{Python}
a platforma \textit{Node.js}, kter\'y slouž\'{\i} jako
běhové prostřed\'{\i} pro jazyk \textit{JavaScript}.
V\'yběr byl proveden na základě aktuáln\'{\i}ch trendů
ve světě softwarového inžen\'yrstv\'{\i}. Projekt GitHut~\cite{githut}
z roku 2014, kter\'y shrnuje statistiky repozitářů
populárn\'{\i} služby pro hosting a sd\'{\i}len\'{\i} kódu
GitHub\footnote{https://github.com/}, určil
jazyky JavaScript, Java a Python jako tři nejaktivnějš\'{\i}.
Služba GitHub následně sama zveřejnila statistiky za rok 2017
v rámci projektu Octoverse~\cite{octoverse}
a dospěla ke stejnému závěru, ačkoliv Python se um\'{\i}stil na druhé
pozici na úkor jazyka Java. Podle průzkumu obl\'{\i}beného
programátorského webového portálu Stack
Overflow~\cite{stackoverflowsurvey} se um\'{\i}stily tyto jazyky
v prvn\'{\i} čtveřici nejpopulárnějš\'{\i}ch jazyků pro obecné použit\'{\i}.

\section{Sd\'{\i}len\'{\i} byznys kontextů mezi službami}

\goal{Formát pro přenos pravidel po s\'{\i}ti a jeho v\'yhody}
Abychom mohli sd\'{\i}let byznysové kontexty a jejich pravidla
mezi jednotliv\'ymi službami, mus\'{\i}me mezi nimi vybudovat
s\'{\i}ťové komunikačn\'{\i} kanály. Je tedy nutné zvolit protokol
a jednotn\'y formát, ve kterém spolu budou služby komunikovat.
Tento formát mus\'{\i} b\'yt nezávisl\'y na platformě a ideálně
by měl b\'yt co nejefektivnějš\'{\i} v rychlosti přenosu.

\goal{Architektura klient-server pro komunikaci kontextů mezi službami}
Pro s\'{\i}ťovou komunikaci se nab\'{\i}z\'{\i} využ\'{\i}t architekturu
\textit{klient-server}, kterou jsme detailněji popsali
v sekci~\ref{sec:client-server}. Při sd\'{\i}len\'{\i} kontextů
lze chápat \textit{klienta} jako službu, která pro svou funkci
vyžaduje z\'{\i}skán\'{\i} kontextu definovaného v jiné službě.
Jako \textit{server} lze naopak chápat službu, která poskytne
své kontexty jiné službě, která na nich závis\'{\i}. Jin\'ymi slovy,
klient si vyžádá potřebné kontexty od serveru a ten mu je v
odpovědi zašle. Může se také stát, že některá služba bude zároveň
serverem jedné služby, a zároveň klientem druhé služby.

\subsection{Protocol Buffers}

\goal{Proč jsme použili Protobuf}
Pro přenos byznysov\'ych kontextů byl zvolen open-source formát
\textit{Protocol Buffers}\footnote{https://developers.google.com/protocol-buffers/}\cite{varda2008protocol}
vyvinut\'y společnost\'{\i} Google\footnote{https://www.google.com/}.
Umožňuje explicitně definovat a vynucovat schéma dat,
která jsou přenášena po s\'{\i}ti, bez vazby na konkrétn\'{\i} programovac\'{\i}
jazyk. Zároveň poskytuje obslužné knihovny pro naše vybrané platformy.
Nav\'{\i}c je d\'{\i}ky binárn\'{\i} reprezentaci dat v přenosu velmi efektivn\'{\i},
oproti formátům jako je \gls{JSON} nebo \gls{XML}~\cite{maeda2012performance}.
Tím splňujeme i požadavek ze sekce~\ref{sec:saving-context} na minimalizaci dopadu
síťového provozu týkajícího se byznysových kontextů na výkon celého systému.
Oproti protokolům \textit{Apache Thrift}\footnote{https://thrift.apache.org/}
a \textit{Apache Avro}\footnote{https://avro.apache.org/}, které poskytuj\'{\i}
velmi srovnatelnou funkcionalitu, maj\'{\i} Protocol Buffers
kvalitnějš\'{\i} a lépe srozumitelnou dokumentaci.

\lstinputlisting[
caption={Část definice schématu zpráv byznys kontextů v jazyce Protobuffer},
label={lst:protobuf-example},
language=protobuf2,
style=protobuf,
%frame=single,
%float,
%floatplacement=H
]{code/protobuffer_example.proto}

Zdrojov\'y kód~\ref{lst:protobuf-example} znázorňuje část zápisu schématu
zas\'{\i}lan\'ych zpráv obsahuj\'{\i}c\'{\i} byznys kontexty ve formátu Protobuffer.
Schéma zpráv pro v\'yměnu kontextů opisuje strukturu metamodelu navrženého
v sekci~\ref{sec:metamodel}.

\begin{description}
    \item [ExpressionMessage] obsahuje jméno, atributy a argumenty \code{Expression}
    \item [ExpressionPropertyMessage] je enumerace obsahuj\'{\i}c\'{\i} typy atributu \code{Expression}
    \item [PreconditionMessage] obsahuje název a podm\'{\i}nku precondition pravidla
    \item [PostConditionMessage] obsahuje název, typ, název odkazovaného pole a podm\'{\i}nku post-condition pravidla
    \item [PostConditionTypeMessage] je enumerace obsahuj\'{\i}c\'{\i} typy post-condition pravidla
    \item [BusinessContextMessage] obsahuje identifikátor, seznam rožš\'{\i}řen\'ych kontextů, seznam preconditions a post-conditions byznys kontextu
    \item [BusinessContextsMessage] obaluje v\'{\i}ce byznys kontextů
\end{description}

\subsection{gRPC}

\goal{Proč jsme použili gRPC}
Pro realizaci architektury klient-server byl zvolen
open-source framework gRPC\footnote{https://grpc.io/}, kter\'y stav\'{\i}
na technologii Protocol Buffers a poskytuje v\'yvojáři
možnost definovat detailn\'{\i} schéma komunikace pomoc\'{\i}
protokolu \textit{\gls{RPC}}~\cite{nelson1981remote}.
Zdrojov\'y kód~\ref{lst:grpc-example} znázorňuje zápis serveru,
kter\'y umožňuje svému klientovi volat metody \code{FetchContexts()},
\code{FetchAllContexts()} a \code{UpdateOrSaveContext()}.

\lstinputlisting[
caption={Definice služby pro komunikaci byznys kontextů pro gRPC},
label={lst:grpc-example},
language=protobuf2,
style=protobuf,
%frame=single,
%float,
%floatplacement=H
]
{code/grpc_example.proto}

\paragraph{FetchContexts()} je metoda, která umožňuje klientovi
z\'{\i}skat kontexty, jejichž identifikátory zašle jako argument
typu \code{BusinessContextRequestMessage}.
V odpovědi pak obdrž\'{\i} dotazované kontexty a nebo chybovou hlášku,
pokud kontexty s dan\'ymi identifikátory nemá server k dispozici.

\paragraph{FetchAllContexts()} dovoluje klientovi z\'{\i}skat všechny
dostupné kontexty serveru. Tato metoda je využ\'{\i}vána pro administraci
kontextů, kdy je potřeba z\'{\i}skat všechny kontexty všech služeb, aby
nad nimi mohly prob\'{\i}hat úpravy a anal\'yzy.

\paragraph{UpdateOrSaveContext()} slouž\'{\i} pro uložen\'{\i} nového či
editovaného pravidla, které je zasláno v serializované podobě
jako jedin\'y argument typu \code{BusinessContextUpdateRequestMessage}.

\section{Doménově specifick\'y jazyk pro popis byznys kontextů}\label{sec:dsl-impl}

\goal{Popsat proč a jak jsme tvořili DSL}
Ačkoliv nen\'{\i} specifikace a vytvořen\'{\i} doménově specifického jazyka (\gls{DSL})
hlavn\'{\i}m úkolem této práce, pro ověřen\'{\i} konceptu bylo nutné nadefinovat
alespoň jeho zjednodušenou verzi a implementovat část knihovny, která
bude umět jazyk zpracovat a sestavit z něj byznysov\'y kontext v paměti programu.

\goal{Důvody pro v\'yběr XML}
Pro popis kontextů byl jako kompromis mezi jednoduchost\'{\i} implementace
a př\'{\i}větivost\'{\i} pro koncového uživatele zvolen univerzáln\'{\i} formát Extensible
Markup Language (\gls{XML})~\cite{bray1997extensible}. Tento
jazyk umožňuje serializaci libovoln\'ych dat, př\'{\i}močar\'y a formáln\'{\i}
zápis jejich struktury a také jejich snadné aplikačn\'{\i} zpracován\'{\i}.
Zároveň poskytuje relativně dobrou čitelnost pro člověka, ačkoliv
speciálně vytvořené \gls{DSL} by bylo jistě čitelnějš\'{\i}.

\goal{Popis jak XML funguje}
Dokumenty \gls{XML} se skládaj\'{\i} z tzv. \textit{entit}, které obsahuj\'{\i}
buď parsovaná nebo neparsovaná data. Parsovaná data se skládaj\'{\i}
z jednoduch\'ych znaků reprezentuj\'{\i}c\'{\i}ch prost\'y text a nebo
speciáln\'{\i}ch značek, neboli \textit{markup}, které slouž\'{\i} k popisu
struktury dat. Naopak neparsovaná data mohou obsahovat libovolné
znaky, které nenesou žádnou informaci o struktuře dat.

\goal{Popis jak\'y formát jsme zvolili pro formáln\'{\i} zápis schématu XML dokumentu}
Vzhledem k tomu, že \gls{XML} je volně rozšiřiteln\'y jazyk a neklade
meze v možnostech struktury dat, bylo potřeba jasně definovat
a dokumentovat očekávanou strukturu dokumentu popisuj\'{\i}c\'{\i}ho
byznys kontext. Pro jazyk \gls{XML} existuje v\'{\i}cero možnost\'{\i} jak schéma
definovat~\cite{lee2000comparative}, od jednoduchého formátu
\textit{DTD} až po komplexn\'{\i} formáty jako je \textit{Schematron}, či
\textit{XML Schema Definition} (\gls{XSD}), kter\'y byl nakonec zvolen.
D\'{\i}ky formálně definovanému schématu můžeme popis byznys kontextu
automaticky validovat a vyvarovat se tak př\'{\i}padn\'ych chyb.

\goal{Popis formátu}
Ve zdrojovém kódu~\ref{lst:business-context-xml} můžeme vidět
př\'{\i}klad zápisu jednoduchého byznys kontextu s jednou precondition.
Samotn\'y zápis byznys kontextu je obsažen v kořenovém elementu
\code{<businessContext>} a jeho název je popsán atributy
\code{prefix} a \code{name}. Rozš\'{\i}řené kontexty jsou vyčteny
v entitě \code{<includedContexts>}. Preconditions jsou
definovány uvnitř entity \code{<preconditions>} a podobně
jsou definovány \code{<postconditions>}. Obsažená data odpov\'{\i}daj\'{\i}
navrženému metamodelu byznysového kontextu z kapitoly~\ref{ch:navrh}.
% TODO: ověřit že to v t\'y kapitole fakt mám, možná i odkaz na konkrétn\'{\i} odstavec
Pro zápis podm\'{\i}nek jednotliv\'ych preconditions a post-conditions byl zvolen
opis Expression \gls{AST}. Toto rozhodnut\'{\i} vycház\'{\i} z předpokladu,
že lze vzhledem k povaze prototypu relaxovat podm\'{\i}nku
na čitelnost zápisu pravidel ve prospěch jednodušš\'{\i}ho zpracován\'{\i}.

\goal{Shrnut\'{\i} DSL}
Podařilo se nám navrhnout přijateln\'y formát zápisu byznys kontextu
a implementovat části knihoven, které uměj\'{\i} formát č\'{\i}st a zároveň vytvářet.
T\'{\i}m jsme dosáhli možnosti zapisovat kontexty bez ohledu na platformu
služby, která je bude využ\'{\i}vat. Zároveň tomuto formátu mohou
snáze porozumět doménov\'{\i} experti a mohou se tak zapojit do
v\'yvojového procesu.

\lstinputlisting[
caption={Př\'{\i}klad zápisu byznys kontextu v jazyce \gls{XML}},
label={lst:business-context-xml},
language=XML,
%frame=single,
%float,
%floatplacement=H
]
{code/business_context.xml}

\section{Knihovna pro platformu Java}

\todo{
\begin{itemize}
    \item Popis business context registry
    \item Popis expression AST
    \item Popis tř\'{\i}d kolem business kontextu
    \item Popis XML parseru a generátoru
    \item Popis server a klient tř\'{\i}d pro obsluhu GRPC
    \item Popis weaveru
    \item Popis anotac\'{\i} pro AOP
    \item Návrhové vzory - builder pro kontexty a pravidla
    \item Návrhové vzory - visitor pro převod expression do xml
    \item Návrhové vzory - interpreter pro interpretaci pravidel
\end{itemize}
}

\subsection{Popis implementace}

\paragraph{BusinessContextRegistry}

\lstinputlisting[
caption={Označen\'{\i} operačn\'{\i}ho kontextu a jeho parametrů pomoc\'{\i} anotac\'{\i} Java knihovny},
label={lst:business-operation-aspectj},
language=Java,
%frame=single,
%float,
%floatplacement=H
]
{code/business_operation_aspectj.java}

\subsection{Použité technologie}

\paragraph{Apache Maven}

\goal{Správa závislost\'{\i} a buildu projektu}
Pro správu závislost\'{\i} a automatickou kompilaci a sestavován\'{\i}
knihovny napsané v jazyce java byl zvolen projekt
\textit{Maven}\footnote{https://maven.apache.org/}.
Tento nástroj umožňuje v\'yvojáři komfortně a centrálně
spravovat závislosti jeho projektu včetně detailn\'{\i}ho
popisu jejich verze. Dále také umožňuje definovat jak\'ym
způsobem bude projekt kompilován.

\paragraph{AspectJ}

\goal{Proč AspectJ a co to um\'{\i}}
Knihovna AspectJ přináš\'{\i} pro jazyk Java sadu nástrojů,
d\'{\i}ky kter\'ym lze snadno implementovat koncepty aspektově orientovaného
programován\'{\i}, zejména pak snadn\'y zápis pointcuts a kompletn\'{\i}
engine pro weaving aspektů.

\todo{
\begin{itemize}
    \item Ukázka kódu knihovny
\end{itemize}
}

\paragraph{JDOM 2}

\goal{Proč jdom2 a co to um\'{\i}}
Knihovna JDOM 2\footnote{http://www.jdom.org/} poskytuje
kompletn\'{\i} sadu nástroju pro čten\'{\i} a zápis \gls{XML} dokumentů.
Implementuje specifikaci \textit{Document Object Model} (\gls{DOM})~\cite{wood2004document},
pomoc\'{\i} které lze programaticky sestavovat a č\'{\i}st \gls{XML} dokumenty.
Tuto knihovnu jsme využili pro serializaci a deserializaci
\gls{DSL} byznys kontextů popsan\'ych v sekci~\ref{sec:dsl-impl}.

\section{Knihovna pro platformu Python}

Knihovna pro platformu jazyka Python využ\'{\i}vá jeho
verzi 3.6. Pomoc\'{\i} nástroje \textit{pip}\footnote{https://pip.pypa.io/en/stable/}
lze knihovnu nainstalovat a využ\'{\i}vat jako python modul.
Implementace odpov\'{\i}dá navržené specifikaci.

\todo{
\begin{itemize}
    \item Srovnán\'{\i} řešen\'{\i} s knihovnou Java
    \item Problémy pythonu a jak byly vyřešeny
    \item Ukázka kódu knihovny
    \item Použité technologie
    \item Ukázka AOP v pythonu pomoc\'{\i} vestavěn\'ych dekorátorů
    \item Knihovna pro GRPC
    \item Popis weaveru
\end{itemize}
}

\subsection{Srovnán\'{\i} s knihovnou pro platformu Java}

\paragraph{Weaving} Největš\'{\i}m rozd\'{\i}lem oproti knihovně pro
jazyk Java je implementace weavingu byznys kontextů.
Jazyk Python totiž d\'{\i}ky své dynamické povaze a vestavěnému
systému dekorátorů umožňuje aplikovat principy aspektově orientovaného
programován\'{\i} bez potřeby dodatečn\'ych knihoven či technologi\'{\i}.
Zdrojov\'y kód~\ref{lst:python-weaving-example} znázorňuje
definici a použit\'{\i} dekorátoru \code{business\textunderscore operation}.
Jak můžeme vidět, je potřeba dekorátoru předat samotn\'y weaver, narozd\'{\i}l
od implementace v Javě, kdy se o předán\'{\i} weaveru postará dependency
injection container.

\lstinputlisting[
caption={Př\'{\i}klad použit\'{\i} dekorátorů pro weaving v jazyce Python},
label={lst:python-weaving-example},
language=Python,
%frame=single,
%float,
%floatplacement=H
]
{code/python_weaving.py}

\paragraph{}

\subsection{Použité technologie}

\section{Knihovna pro platformu Node.js}

Knihovna pro platformu \textit{Node.js} byla implementována
v jazyce JavaScript, konkrétně jeho verzi
ECMAScript 6.0~\cite{ecma60}.
Implementace odpov\'{\i}dá specifikaci návrhu, umožňuje
instalaci pomoc\'{\i} bal\'{\i}čkovac\'{\i}ho nástroje a snadnou
integraci do kódu v\'ysledné služby.

\subsection{Srovnán\'{\i} s knihovnou pro platformu Java}

\paragraph{Weaving} Podobně jako v knihovně pro jazyk Python,
i v knihovně pro Node.js byl oproti knihovně pro jazyk Java
největš\'{\i} rozd\'{\i}l v implementaci weavingu. Platforma Node.js
totiž nedisponuje žádnou kvalitn\'{\i} knihovnou, která by ulehčila
využit\'{\i} konceptů aspektově orientovaného programován\'{\i}.
Jazyk JavaScript je ale velmi flexibiln\'{\i} a lze
tedy pro dosažen\'{\i} požadované funkcionality využ\'{\i}t
podobně jako pro jazyk Python princip dekorátoru jako funkce.
Ačkoliv zápis dekorátoru nen\'{\i} př\'{\i}liš elegantn\'{\i} a kvůli
použit\'{\i} konceptu \textit{Promise}~\cite{kambona2013evaluation}
poněkud složitějš\'{\i}, podařilo se weaving implementovat spolehlivě.
Ukázku můžeme vidět ve zdrojovém kódu~\ref{lst:nodejs-weaving}.
Funkce \code{register()} obsahuje logiku pro registraci uživatele,
která může obsahovat např\'{\i}klad uložen\'{\i} entity do databáze a odeslán\'{\i}
registračn\'{\i}ho e-mailu. Při exportován\'{\i} funkce z Node.js modulu
využijeme \code{wrapCall()}, která má za úkol dekorovat
předanou funkci \code{func}, před jej\'{\i}m zavolán\'{\i} vyhodnotit
preconditions a po zavolán\'{\i} aplikovat post-conditions.
D\'{\i}ky tomu bude každ\'y kód, kter\'y využije modul definuj\'{\i}c\'{\i} funkci
pro registraci uživatele, pracovat s dekorovanou funkc\'{\i}.

\paragraph{Využit\'{\i} gRPC} Narozd\'{\i}l od implementac\'{\i} knihovny
v jazyc\'{\i}ch Java a Python um\'{\i} knihovna obsluhuj\'{\i}c\'{\i} gRPC
fungovat i bez předgenerovaného kódu. To poněkud usnadnilo
práci při serializaci byznys kontextů do přenosového formátu
i při deserializaci a ukládán\'{\i} kontextů do paměti. Úspora
kódu je ale na úkor typové kontroly a tak může b\'yt kód náchylnějš\'{\i}
na lidskou chybu.

\lstinputlisting[
caption={Př\'{\i}klad dekorace funkce v JavaScriptu pro aplikaci weavingu},
label={lst:nodejs-weaving},
language=JavaScript,
%frame=single,
%float,
%floatplacement=H
]
{code/nodejs_weaving.js}

\subsection{Použité technologie}

\goal{Použité technologie pro v\'yvoj knihovny}
Podobně jako byl použit nástroj Maven pro knihovnu v jazyce Java byl
využit bal\'{\i}čkovac\'{\i} nástroj \textit{NPM}, kter\'y je předinstalován
v běhovém prostřed\'{\i} \textit{Node.js}. Tento nástroj ale nedisponuje
př\'{\i}liš silnou podporou pro správu automatick\'ych sestaven\'{\i} knihovny
a v základn\'{\i}m nastaven\'{\i} nen\'{\i} ani př\'{\i}liš efektivn\'{\i} pro správu závislost\'{\i}.
Proto bylo nutné využ\'{\i}t dodatečné knihovny, jmenovitě
\textit{Yarn}\footnote{https://yarnpkg.com/en/}, \textit{Babel}\footnote{https://babeljs.io/} a
\textit{Rimraf}\footnote{https://github.com/isaacs/rimraf}.

\section{Systém pro centráln\'{\i} správu byznys pravidel}\label{sec:central-administration}

\todo{
\begin{itemize}
    \item Jak funguje systém
    \item Přehled, detail a úprava pravidla
    \item \code{BusinessContextEditor}
    \item Uložen\'{\i} pravidla
\end{itemize}
}

% TODO: hodit sem použité návrhové vzory, určitě je tam visitor, factory a builder
% TODO: nebo možná do návrhu?

\subsection{Popis implementace}

\paragraph{BusinessContextEditor} % TODO: dopsat co dělá?

\subsection{Detekce a prevence potenciáln\'{\i}ch problémů}

\goal{Problémy způsobené rozšiřován\'{\i}m kontextů}
Jak jsme již naznačili v sekci~\ref{sec:context-inheritance},
při úpravě nebo vytvářen\'{\i} nového byznysového kontextu je
potřeba detekovat př\'{\i}padné chyby, abychom změnou neuvedli
systém do nefunkčn\'{\i}ho stavu. Kromě syntaktick\'ych chyb,
které jsou detekovány automaticky pomoc\'{\i} definovaného schematu,
je potřeba věnovat pozornost také sémantick\'ym chybám.
Závažné chyby, které mohou b\'yt způsobeny rozšiřován\'{\i}m kontextů, jsou
\begin{enumerate}[label=\alph*)]
    \item Neunikátní identifikátory byznysových pravidel
    \item Závislosti na neexistuj\'{\i}c\'{\i}ch kontextech
    \item Cyklus v grafu závislost\'{\i} kontextů
    \item Vzájemná kontradikce preconditions
\end{enumerate}

\goal{Chápán\'{\i} kontextů jako grafu}
Kontexty a jejich vzájemné závislosti lze vn\'{\i}mat jako
orientovan\'y graf, kde uzel grafu reprezentuje kontext
a orientovaná hrana reprezentuje závislost mezi kontexty.
Směr závislosti můžeme pro naše účely zvolit libovolně.

\goal{Detekce závislost\'{\i} na neexistuj\'{\i}c\'{\i}ch kontextech}
Detekce závislosti na neexistuj\'{\i}c\'{\i}ch kontextech je relativně
jednoduch\'ym úkolem. Nejprve setav\'{\i}me seznam existuj\'{\i}c\'{\i}ch kontextů
a následně procház\'{\i}me jednotlivé hrany grafu kontextů a ověřujeme,
zda existuj\'{\i} oba kontexty nálež\'{\i}c\'{\i} dané hraně.
Při zvolen\'{\i} vhodn\'ych datov\'ych struktur lze dosáhnout
lineárn\'{\i} složitosti v závislosti na počtu hran grafu.

% TODO: detekce duplicitních kontextů

% TODO: detekce protichůdných preconditions

\goal{Detekce cyklů v grafu závislost\'{\i}}
Pokud by závislosti v orientovaném grafu vytvořily cyklus, tedy kruhovou závislost
kontextů, kteoru jsme představili v sekci~\ref{sec:context-inheritance},
docházelo by při inicializaci služeb obsahuj\'{\i}c\'{\i} daná pravidla k zacyklen\'{\i}.
Tomu můžeme předej\'{\i}t detekc\'{\i} cyklů v grafu. Pro tuto detekci byl zvolen
Tarjanův algoritmus~\cite{tarjan1971depth} pro detekci souvisl\'ych
komponent, kter\'y disponuje velmi dobrou lineárn\'{\i} složitost\'{\i},
závislou na součtu počtu hran a počtu uzlů grafu.

\goal{Reakce na chyby}
V př\'{\i}padě, že zápis nového či praveného kontextu obsahuje syntaktické
chyby a nebo způsobuje některou z detekovan\'ych chyb v závislostech,
administrace nedovol\'{\i} uživateli změnu provést a vyp\'{\i}še informativn\'{\i}
chybovou hlášku.

\subsection{Použité technologie}

\paragraph{Uživatelské rozhran\'{\i}}
Pro komfortn\'{\i} obsluhu centráln\'{\i} administrace bylo naprogramováno
uživatelské rozhran\'{\i} pomoc\'{\i} technologi\'{\i} Hypertext Markup Language~\cite{berners1995hypertext}
(HTML) a Cascading Style Sheets~\cite{bos1998cascading} (\gls{CSS}), které jsou již několik
desetilet\'{\i} standarderm pro tvorbu webov\'ych uživatelsk\'ych rozhran\'{\i}.
Detail byznysového kontextu v uživatelském rozhran\'{\i} můžeme vidět na sn\'{\i}mku~\ref{fig:screenshot-context-detail}
a formulář pro úpravu na sn\'{\i}mku~\ref{fig:screenshot-context-edit}.

\todo{
\begin{itemize}
    \item Uživatelské rozhran\'{\i} v HTML + CSS
    \item Jak jsme použili Spring Boot a jeho MVC k nastaven\'{\i} základn\'{\i} webové aplikace
    \item Dependency Injection Container
    \item Využit\'{\i} knihovny pro platformu Java
\end{itemize}
}

\section{Shrnut\'{\i}}

\goal{Dosáhli jsme vytyčen\'ych c\'{\i}lů implementace}
Na základě navrženého frameworku jsme implementovali prototypy
knihoven pro platformy jazyka Java, jazyka Python a frameworku
Node.js. Knihovny umožňuj\'{\i} centráln\'{\i} správu a automatickou distribuci
byznysov\'ych kontextů, včetně vyhodnocován\'{\i} jejich pravidel, za
použit\'{\i} aspektově orientovaného př\'{\i}stupu.
Dále jsme specifikovali \gls{DSL}, kter\'ym lze popsat byznys kontext
nezávisle na platformě.

\goal{Hostován\'{\i} na GitHubu + licence}
Vešker\'y kód je hostován v centráln\'{\i}m repozitáři
ve službě GitHub\footnote{
https://github.com/klimesf/diploma-thesis
} a je zpř\'{\i}stupněn pod open-source licenc\'{\i} MIT~\cite{mitlicense}.
Knihovny pro jednotlivé platformy tedy lze libovolně
využ\'{\i}vat, modifikovat a š\'{\i}řit.

\goal{Validaci a verifikaci si ještě ukážeme}
Protoypy knihoven lze využ\'{\i}t k implementaci služeb,
potažmo k sestaven\'{\i} funkčn\'{\i}ho systému, jak si ukážeme
v následuj\'{\i}c\'{\i} kapitole.
