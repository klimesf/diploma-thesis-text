%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}

%!TEX ROOT=../diploma-thesis.tex

\chapter{Implementace prototypů knihoven}\label{ch:implementace}

\goal{Uvedení kapitoly a nastínění obsahu}
Součástí zadání této práce je implementace prototypů
knihoven pro framework navržený v kapitole~\ref{ch:navrh}
pro tři rozdílné platformy, z nichž jedna musí být \textit{Java}.
V této kapitole si popíšeme, jaké plaformy jsme vybraly, a jakým
způsobem byly prototypy knihoven implementovány. Součástí
kapitoly je i stručná rešerše technologií, které byly použity
pro dosažení vytyčených cílů.

\goal{Nástin formátu kapitoly}
Jelikož vycházejí implementace knihoven pro všechny platformy
ze stejného návrhu, popíšeme si kompletní implementaci pro jazyk
Java a ostatní implementace shrneme komparativní metodou.

\goal{Technické implementační problémy}
Pro splnění cílů bylo potřeba vyřešit také několik technických otázek,
jako je přenos byznys kontextů mezi jednotlivými službami, výběr formátu
pro zápis byznys kontextu, podpora aspektově orientovaného programování
v daném programovacím jazyce a využití principu \textit{runtime weavingu}
a integrace knihoven do služeb, které je budou využívat.

\section{Výběr použitých platforem}

\goal{Jaké jsme vybrali další platformy a proč}
Mimo jazyk Java, který byl určen zadáním, byla pro
implementaci vybrána platforma jazyka \textit{Python}
a platforma \textit{Node.js}, který slouží jako
běhové prostředí pro jazyk \textit{JavaScript}.
Výběr byl proveden na základě aktuálních trendů
ve světě softwarového inženýrství. Projekt GitHut~\cite{githut}
z roku 2014, který shrnuje statistiky repozitářů
populární služby pro hosting a sdílení kódu
GitHub\footnote{https://github.com/}, určil
jazyky JavaScript, Java a Python jako tři nejaktivnější.
Služba GitHub následně sama zveřejnila statistiky za rok 2017
v rámci projektu Octoverse~\cite{octoverse}
a dospěla ke stejnému závěru, ačkoliv Python se umístil na druhé
pozici na úkor jazyka Java. Podle průzkumu oblíbeného
programátorského webového portálu Stack
Overflow~\cite{stackoverflowsurvey} se umístily tyto jazyky
v první čtveřici nejpopulárnějších jazyků pro obecné použití.

\section{Sdílení byznys kontextů mezi službami}

\goal{Formát pro přenos pravidel po síti a jeho výhody}
Abychom mohli sdílet byznysové kontexty a jejich pravidla
mezi jednotlivými službami, musíme mezi nimi vybudovat
síťové komunikační kanály. Je tedy nutné zvolit protokol
a jednotný formát, ve kterém spolu budou služby komunikovat.
Tento formát musí být nezávislý na platformě a ideálně
by měl být co nejefektivnější v rychlosti přenosu.

\goal{Architektura klient-server pro komunikaci kontextů mezi službami}
Pro síťovou komunikaci se nabízí využít architekturu
\textit{klient-server}, kterou jsme detailněji popsali
v sekci~\ref{sec:client-server}. Při sdílení kontextů
lze chápat \textit{klienta} jako službu, která pro svou funkci
vyžaduje získání kontextu definovaného v jiné službě.
Jako \textit{server} lze naopak chápat službu, která poskytne
své kontexty jiné službě, která na nich závisí. Jinými slovy,
klient si vyžádá potřebné kontexty od serveru a ten mu je v
odpovědi zašle. Může se také stát, že některá služba bude zároveň
serverem jedné služby, a zároveň klientem druhé služby.

\subsection{Protocol Buffers}

\goal{Proč jsme použili Protobuf}
Pro přenos byznysových kontextů byl zvolen open-source formát
\textit{Protocol Buffers}~\cite{protobuf}\cite{varda2008protocol}
vyvinutý společností Google\footnote{https://www.google.com/}.
Umožňuje explicitně definovat a vynucovat schéma dat,
která jsou přenášena po síti, bez vazby na konkrétní programovací
jazyk. Zároveň poskytuje obslužné knihovny pro naše vybrané platformy.
Navíc je díky binární reprezentaci dat v přenosu velmi efektivní,
oproti formátům jako je JSON nebo XML~\cite{maeda2012performance}.
Oproti protokolům \textit{Apache Thrift}~\cite{thrift}
a \textit{Apache Avro}~\cite{avro}, které poskytují
velmi srovnatelnou funkcionalitu, mají Protocol Buffers
kvalitnější a lépe srozumitelnou dokumentaci.

\lstinputlisting[
caption={Část definice schématu zpráv byznys kontextů v jazyce Protobuffer},
label={lst:protobuf-example},
language=protobuf2,
style=protobuf,
%frame=single,
%float,
%floatplacement=H
]{code/protobuffer_example.proto}

Zdrojový kód~\ref{lst:protobuf-example} znázorňuje část zápisu schématu
zasílaných zpráv obsahující byznys kontexty ve formátu Protobuffer.
Schéma zpráv pro výměnu kontextů opisuje strukturu metamodelu navrženého
v sekci~\ref{sec:metamodel}.

\begin{description}
    \item [ExpressionMessage] obsahuje jméno, atributy a argumenty \code{Expression}
    \item [ExpressionPropertyMessage] je enumerace obsahující typy atributu \code{Expression}
    \item [PreconditionMessage] obsahuje název a podmínku precondition pravidla
    \item [PostConditionMessage] obsahuje název, typ, název odkazovaného pole a podmínku post-condition pravidla
    \item [PostConditionTypeMessage] je enumerace obsahující typy post-condition pravidla
    \item [BusinessContextMessage] obsahuje identifikátor, seznam rožšířených kontextů, seznam preconditions a post-conditions byznys kontextu
    \item [BusinessContextsMessage] obaluje více byznys kontextů
\end{description}

\subsection{gRPC}

\goal{Proč jsme použili gRPC}
Pro realizaci architektury klient-server byl zvolen
open-source framework gRPC~\cite{grpcio}, který staví
na technologii Protocol Buffers a poskytuje vývojáři
možnost definovat detailní schéma komunikace pomocí
protokolu \textit{RPC}~\cite{nelson1981remote}.
Zdrojový kód~\ref{lst:grpc-example} znázorňuje zápis serveru,
který umožňuje svému klientovi volat metody \code{FetchContexts()},
\code{FetchAllContexts()} a \code{UpdateOrSaveContext()}.

\lstinputlisting[
caption={Definice služby pro komunikaci byznys kontextů pro gRPC},
label={lst:grpc-example},
language=protobuf2,
style=protobuf,
%frame=single,
%float,
%floatplacement=H
]
{code/grpc_example.proto}

\paragraph{FetchContexts()} je metoda, která umožňuje klientovi
získat kontexty, jejichž identifikátory zašle jako argument
typu \code{BusinessContextRequestMessage}.
V odpovědi pak obdrží dotazované kontexty a nebo chybovou hlášku,
pokud kontexty s danými identifikátory nemá server k dispozici.

\paragraph{FetchAllContexts()} dovoluje klientovi získat všechny
dostupné kontexty serveru. Tato metoda je využívána pro administraci
kontextů, kdy je potřeba získat všechny kontexty všech služeb, aby
nad nimi mohly probíhat úpravy a analýzy.

\paragraph{UpdateOrSaveContext()} slouží pro uložení nového či
editovaného pravidla, které je zasláno v serializované podobě
jako jediný argument typu \code{BusinessContextUpdateRequestMessage}.

\section{Doménově specifický jazyk pro popis byznys kontextů}\label{sec:dsl-impl}

\goal{Popsat proč a jak jsme tvořili DSL}
Ačkoliv není specifikace a vytvoření doménově specifického jazyka (DSL)
hlavním úkolem této práce, pro ověření konceptu bylo nutné nadefinovat
alespoň jeho zjednodušenou verzi a implementovat část knihovny, která
bude umět jazyk zpracovat a sestavit z něj byznysový kontext v paměti programu.

\goal{Důvody pro výběr XML}
Pro popis kontextů byl jako kompromis mezi jednoduchostí implementace
a přívětivostí pro koncového uživatele zvolen univerzální formát Extensible
Markup Language (XML)~\cite{bray1997extensible}. Tento
jazyk umožňuje serializaci libovolných dat, přímočarý a formální
zápis jejich struktury a také jejich snadné aplikační zpracování.
Zároveň poskytuje relativně dobrou čitelnost pro člověka, ačkoliv
speciálně vytvořené DSL by bylo jistě čitelnější.

\goal{Popis jak XML funguje}
Dokumenty XML se skládají z tzv. \textit{entit}, které obsahují
buď parsovaná nebo neparsovaná data. Parsovaná data se skládají
z jednoduchých znaků reprezentujících prostý text a nebo
speciálních značek, neboli \textit{markup}, které slouží k popisu
struktury dat. Naopak neparsovaná data mohou obsahovat libovolné
znaky, které nenesou žádnou informaci o struktuře dat.

\goal{Popis jaký formát jsme zvolili pro formální zápis schématu XML dokumentu}
Vzhledem k tomu, že XML je volně rozšiřitelný jazyk a neklade
meze v možnostech struktury dat, bylo potřeba jasně definovat
a dokumentovat očekávanou strukturu dokumentu popisujícího
byznys kontext. Pro jazyk XML existuje vícero možností jak schéma
definovat~\cite{lee2000comparative}, od jednoduchého formátu
\textit{DTD} až po komplexní formáty jako je \textit{Schematron}, či
\textit{XML Schema Definition} (XSD), který byl nakonec zvolen.
Díky formálně definovanému schématu můžeme popis byznys kontextu
automaticky validovat a vyvarovat se tak případných chyb.

\goal{Popis formátu}
Ve zdrojovém kódu~\ref{lst:business-context-xml} můžeme vidět
příklad zápisu jednoduchého byznys kontextu s jednou precondition.
Samotný zápis byznys kontextu je obsažen v kořenovém elementu
\code{<businessContext>} a jeho název je popsán atributy
\code{prefix} a \code{name}. Rozšířené kontexty jsou vyčteny
v entitě \code{<includedContexts>}. Preconditions jsou
definovány uvnitř entity \code{<preconditions>} a podobně
jsou definovány \code{<postconditions>}. Obsažená data odpovídají
navrženému metamodelu byznysového kontextu z kapitoly~\ref{ch:navrh}.
% TODO: ověřit že to v tý kapitole fakt mám, možná i odkaz na konkrétní odstavec
Pro zápis podmínek jednotlivých preconditions a post-conditions byl zvolen
opis Expression AST. Toto rozhodnutí vychází z předpokladu,
že lze vzhledem k povaze prototypu relaxovat podmínku
na čitelnost zápisu pravidel ve prospěch jednoduššího zpracování.

\goal{Shrnutí DSL}
Podařilo se nám navrhnout přijatelný formát zápisu byznys kontextu
a implementovat části knihoven, které umějí formát číst a zároveň vytvářet.
Tím jsme dosáhli možnosti zapisovat kontexty bez ohledu na platformu
služby, která je bude využívat. Zároveň tomuto formátu mohou
snáze porozumět doménoví experti a mohou se tak zapojit do
vývojového procesu.

\lstinputlisting[
caption={Příklad zápisu byznys kontextu v jazyce XML},
label={lst:business-context-xml},
language=XML,
%frame=single,
%float,
%floatplacement=H
]
{code/business_context.xml}

\section{Knihovna pro platformu Java}

\todo{
\begin{itemize}
    \item Popis business context registry
    \item Popis expression AST
    \item Popis tříd kolem business kontextu
    \item Popis XML parseru a generátoru
    \item Popis server a klient tříd pro obsluhu GRPC
    \item Popis weaveru
    \item Popis anotací pro AOP
    \item Návrhové vzory - builder pro kontexty a pravidla
    \item Návrhové vzory - visitor pro převod expression do xml
    \item Návrhové vzory - interpreter pro interpretaci pravidel
\end{itemize}
}

\subsection{Popis implementace}

\paragraph{BusinessContextRegistry}

\lstinputlisting[
caption={Označení operačního kontextu a jeho parametrů pomocí anotací Java knihovny},
label={lst:business-operation-aspectj},
language=Java,
%frame=single,
%float,
%floatplacement=H
]
{code/business_operation_aspectj.java}

\subsection{Použité technologie}

\paragraph{Apache Maven}

\goal{Správa závislostí a buildu projektu}
Pro správu závislostí a automatickou kompilaci a sestavování
knihovny napsané v jazyce java byl zvolen projekt \textit{Maven}~\cite{maven}.
Tento nástroj umožňuje vývojáři komfortně a centrálně
spravovat závislosti jeho projektu včetně detailního
popisu jejich verze. Dále také umožňuje definovat jakým
způsobem bude projekt kompilován.

\paragraph{AspectJ}

\goal{Proč AspectJ a co to umí}
Knihovna AspectJ přináší pro jazyk Java sadu nástrojů,
díky kterým lze snadno implementovat koncepty aspektově orientovaného
programování, zejména pak snadný zápis pointcuts a kompletní
engine pro weaving aspektů.

\todo{
\begin{itemize}
    \item Ukázka kódu knihovny
\end{itemize}
}

\paragraph{JDOM 2}

\goal{Proč jdom2 a co to umí}
Knihovna JDOM 2~\cite{jdom2} poskytuje
kompletní sadu nástroju pro čtení a zápis XML dokumentů.
Implementuje specifikaci \textit{Document Object Model} (DOM)~\cite{wood2004document},
pomocí které lze programaticky sestavovat a číst XML dokumenty.
Tuto knihovnu jsme využili pro serializaci a deserializaci
DSL byznys kontextů popsaných v sekci~\ref{sec:dsl-impl}.

\section{Knihovna pro platformu Python}

Knihovna pro platformu jazyka Python využívá jeho
verzi 3.6. Pomocí nástroje \textit{pip}~\cite{pip}
lze knihovnu nainstalovat a využívat jako python modul.
Implementace odpovídá navržené specifikaci.

\todo{
\begin{itemize}
    \item Srovnání řešení s knihovnou Java
    \item Problémy pythonu a jak byly vyřešeny
    \item Ukázka kódu knihovny
    \item Použité technologie
    \item Ukázka AOP v pythonu pomocí vestavěných dekorátorů
    \item Knihovna pro GRPC
    \item Popis weaveru
\end{itemize}
}

\subsection{Srovnání s knihovnou pro platformu Java}

\paragraph{Weaving} Největším rozdílem oproti knihovně pro
jazyk Java je implementace weavingu byznys kontextů.
Jazyk Python totiž díky své dynamické povaze a vestavěnému
systému dekorátorů umožňuje aplikovat principy aspektově orientovaného
programování bez potřeby dodatečných knihoven či technologií.
Zdrojový kód~\ref{lst:python-weaving-example} znázorňuje
definici a použití dekorátoru \code{business\textunderscore operation}.
Jak můžeme vidět, je potřeba dekorátoru předat samotný weaver, narozdíl
od implementace v Javě, kdy se o předání weaveru postará dependency
injection container.

\lstinputlisting[
caption={Příklad použití dekorátorů pro weaving v jazyce Python},
label={lst:python-weaving-example},
language=Python,
%frame=single,
%float,
%floatplacement=H
]
{code/python_weaving.py}

\paragraph{}

\subsection{Použité technologie}

\section{Knihovna pro platformu Node.js}

Knihovna pro platformu \textit{Node.js} byla implementována
v jazyce JavaScript, konkrétně jeho verzi
ECMAScript 6.0~\cite{ecma60}.
Implementace odpovídá specifikaci návrhu, umožňuje
instalaci pomocí balíčkovacího nástroje a snadnou
integraci do kódu výsledné služby.

\subsection{Srovnání s knihovnou pro platformu Java}

\paragraph{Weaving} Podobně jako v knihovně pro jazyk Python,
i v knihovně pro Node.js byl oproti knihovně pro jazyk Java
největší rozdíl v implementaci weavingu. Platforma Node.js
totiž nedisponuje žádnou kvalitní knihovnou, která by ulehčila
využití konceptů aspektově orientovaného programování.
Jazyk JavaScript je ale velmi flexibilní a lze
tedy pro dosažení požadované funkcionality využít
podobně jako pro jazyk Python princip dekorátoru jako funkce.
Ačkoliv zápis dekorátoru není příliš elegantní a kvůli
použití konceptu \textit{Promise}~\cite{kambona2013evaluation}
poněkud složitější, podařilo se weaving implementovat spolehlivě.
Ukázku můžeme vidět ve zdrojovém kódu~\ref{lst:nodejs-weaving}.
Funkce \code{register()} obsahuje logiku pro registraci uživatele,
která může obsahovat například uložení entity do databáze a odeslání
registračního e-mailu. Při exportování funkce z Node.js modulu
využijeme \code{wrapCall()}, která má za úkol dekorovat
předanou funkci \code{func}, před jejím zavolání vyhodnotit
preconditions a po zavolání aplikovat post-conditions.
Díky tomu bude každý kód, který využije modul definující funkci
pro registraci uživatele, pracovat s dekorovanou funkcí.

\paragraph{Využití gRPC} Narozdíl od implementací knihovny
v jazycích Java a Python umí knihovna obsluhující gRPC
fungovat i bez předgenerovaného kódu. To poněkud usnadnilo
práci při serializaci byznys kontextů do přenosového formátu
i při deserializaci a ukládání kontextů do paměti. Úspora
kódu je ale na úkor typové kontroly a tak může být kód náchylnější
na lidskou chybu.

\lstinputlisting[
caption={Příklad dekorace funkce v JavaScriptu pro aplikaci weavingu},
label={lst:nodejs-weaving},
language=JavaScript,
%frame=single,
%float,
%floatplacement=H
]
{code/nodejs_weaving.js}

\subsection{Použité technologie}

\goal{Použité technologie pro vývoj knihovny}
Podobně jako byl použit nástroj Maven pro knihovnu v jazyce Java byl
využit balíčkovací nástroj \textit{NPM}, který je předinstalován
v běhovém prostředí \textit{Node.js}. Tento nástroj ale nedisponuje
příliš silnou podporou pro správu automatických sestavení knihovny
a v základním nastavení není ani příliš efektivní pro správu závislostí.
Proto bylo nutné využít dodatečné knihovny, jmenovitě
\textit{Yarn}~\cite{yarnpkg}, \textit{Babel}~\cite{babel} a
\textit{Rimraf}~\cite{rimraf}.

\section{Systém pro centrální správu byznys pravidel}

\todo{
\begin{itemize}
    \item Jak funguje systém
    \item Přehled, detail a úprava pravidla
    \item \code{BusinessContextEditor}
    \item Uložení pravidla
\end{itemize}
}



\subsection{Popis implementace}

\paragraph{BusinessContextEditor} % TODO: dopsat co dělá?

\subsection{Detekce a prevence potenciálních problémů}

\goal{Problémy způsobené rozšiřováním kontextů}
Při úpravě nebo vytváření nového byznysového kontextu je
potřeba detekovat případné chyby, abychom změnou neuvedli
systém do nekonzistentního stavu. Kromě syntaktických chyb,
které jsou detekovány automaticky pomocí definovaného schematu,
je potřeba věnovat pozornost také sémantickým chybám.
Závažné chyby, které mohou být způsobeny rozšiřováním kontextů, jsou
\begin{enumerate}[label=\alph*)]
    \item Závislosti na neexistujících kontextech
    \item Cyklus v grafu závislostí kontextů
\end{enumerate}

\goal{Chápání kontextů jako grafu}
Kontexty a jejich vzájemné závislosti lze vnímat jako
orientovaný graf, kde uzel grafu reprezentuje kontext
a orientovaná hrana reprezentuje závislost mezi kontexty.
Směr závislosti můžeme pro naše účely zvolit libovolně.

\goal{Detekce závislostí na neexistujících kontextech}
Detekce závislosti na neexistujících kontextech je relativně
jednoduchým úkolem. Nejprve setavíme seznam existujících kontextů
a následně procházíme jednotlivé hrany grafu kontextů a ověřujeme,
zda existují oba kontexty náležící dané hraně.
Při zvolení vhodných datových struktur lze dosáhnout
lineární složitosti v závislosti na počtu hran grafu.

\goal{Detekce cyklů v grafu závislostí}
Pokud by závislosti v orientovaném grafu vytvořily cyklus,
docházelo by při inicializaci služeb
obsahující daná pravidla k zacyklení. Tomu můžeme předejít
detekcí cyklů v grafu. Pro tuto detekci byl zvolen
Tarjanův algoritmus~\cite{tarjan1971depth} pro detekci souvislých
komponent, který disponuje velmi dobrou lineární složitostí,
závislou na součtu počtu hran a počtu uzlů grafu.

\goal{Reakce na chyby}
V případě, že zápis nového či praveného kontextu obsahuje syntaktické
chyby a nebo způsobuje některou z detekovaných chyb v závislostech,
administrace nedovolí uživateli změnu provést a vypíše informativní
chybovou hlášku.

\subsection{Použité technologie}

\paragraph{Uživatelské rozhraní}
Pro komfortní obsluhu centrální administrace bylo naprogramováno
uživatelské rozhraní pomocí technologií Hypertext Markup Language~\cite{berners1995hypertext}
(HTML) a Cascading Style Sheets~\cite{bos1998cascading} (CSS), které jsou již několik
desetiletí standarderm pro tvorbu webových uživatelských rozhraní.
Detail byznysového kontextu v uživatelském rozhraní můžeme vidět na snímku~\ref{fig:screenshot-context-detail}
a formulář pro úpravu na snímku~\ref{fig:screenshot-context-edit}.

\todo{
\begin{itemize}
    \item Uživatelské rozhraní v HTML + CSS
    \item Jak jsme použili Spring Boot a jeho MVC k nastavení základní webové aplikace
    \item Dependency Injection Container
    \item Využití knihovny pro platformu Java
\end{itemize}
}

\section{Shrnutí}

\goal{Dosáhli jsme vytyčených cílů implementace}
Na základě navrženého frameworku jsme implementovali prototypy
knihoven pro platformy jazyka Java, jazyka Python a frameworku
Node.js. Knihovny umožňují centrální správu a automatickou distribuci
byznysových kontextů, včetně vyhodnocování jejich pravidel, za
použití aspektově orientovaného přístupu.
Dále jsme specifikovali DSL, kterým lze popsat byznys kontext
nezávisle na platformě.

\goal{Hostování na GitHubu + licence}
Veškerý kód je hostován v centrálním repozitáři
ve službě GitHub\footnote{
https://github.com/klimesf/diploma-thesis
} a je zpřístupněn pod open-source licencí MIT~\cite{mitlicense}.
Knihovny pro jednotlivé platformy tedy lze libovolně
využívat, modifikovat a šířit.

\goal{Validaci a verifikaci si ještě ukážeme}
Protoypy knihoven lze využít k implementaci služeb,
potažmo k sestavení funkčního systému, jak si ukážeme
v následující kapitole.
